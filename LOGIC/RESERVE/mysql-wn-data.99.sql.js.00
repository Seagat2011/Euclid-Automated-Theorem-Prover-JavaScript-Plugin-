/*
__import(clb_defines.h)
__import(clb_regmem.h)
__import(cio_commandline.h)
__import(cio_output.h)
__import(ccl_relevance.h)
__import(cco_proofproc.h)
__import(cco_sine.h)
__import(cio_signals.h)
__import(ccl_unfold_defs.h)
__import(ccl_formulafunc.h)
__import(cte_simplesorts.h)
__import(cco_scheduling.h)
__import(e_version.h) */

/*---------------------------------------------------------------------*/
/*                  Data types                                         */
/*---------------------------------------------------------------------*/

var NAME = 'eprover'

Array.prototype.Clone = function()
{
   return this
}

Array.prototype.Repack = function()
{
   var obj = []
   this.map(function(v,i,me){
      if(v){
         obj.push(v)
      }
      return v
   })
   return obj
}

// PERF_CTR_DEFINE(SatTimer);

var typedef_enum_optionCodes = 
[
   'OPT_NOOPT',
   'OPT_HELP',
   'OPT_VERSION',
   'OPT_VERBOSE',
   'OPT_OUTPUT',
   'OPT_PRINT_STATISTICS',
   'OPT_EXPENSIVE_DETAILS',   
   'OPT_PRINT_SATURATED',
   'OPT_PRINT_SAT_INFO',
   'OPT_FILTER_SATURATED',
   'OPT_PRUNE_ONLY',
   'OPT_CNF_ONLY',
   'OPT_PRINT_PID',
   'OPT_PRINT_VERSION',
   'OPT_REQUIRE_NONEMPTY',
   'OPT_SILENT',
   'OPT_OUTPUTLEVEL',
   'OPT_PROOF_OBJECT',
   'OPT_PCL_COMPRESSED',
   'OPT_PCL_COMPACT',
   'OPT_PCL_SHELL_LEVEL',
   'OPT_MEM_LIMIT',
   'OPT_CPU_LIMIT',
   'OPT_SOFTCPU_LIMIT',
   'OPT_RUSAGE_INFO',
   'OPT_STEP_LIMIT',
   'OPT_ANSWER_LIMIT',
   'OPT_CONJ_ARE_QUEST',
   'OPT_PROC_LIMIT',
   'OPT_UNPROC_LIMIT',
   'OPT_TOTAL_LIMIT',
   'OPT_NO_INFIX',
   'OPT_FULL_EQ_REP',
   'OPT_TPTP_PARSE',
   'OPT_TPTP_PRINT',
   'OPT_TPTP_FORMAT',
   'OPT_TSTP_PARSE',
   'OPT_TSTP_PRINT',
   'OPT_TSTP_FORMAT',
   'OPT_AUTO',
   'OPT_SATAUTO',
   'OPT_AUTODEV',
   'OPT_SATAUTODEV',
   'OPT_AUTO_SCHED',
   'OPT_NO_PREPROCESSING',
   'OPT_EQ_UNFOLD_LIMIT',
   'OPT_EQ_UNFOLD_MAXCLAUSES',
   'OPT_NO_EQ_UNFOLD',
   'OPT_SINE',
   'OPT_REL_PRUNE_LEVEL',
   'OPT_PRESAT_SIMPLIY',
   'OPT_AC_HANDLING',
   'OPT_AC_ON_PROC',
   'OPT_LITERAL_SELECT',
   'OPT_NO_GENERATION',
   'OPT_SELECT_ON_PROC_ONLY',
   'OPT_INHERIT_PM_LIT',
   'OPT_INHERIT_GOAL_PM_LIT',
   'OPT_INHERIT_CONJ_PM_LIT',
   'OPT_POS_LITSEL_MIN',
   'OPT_POS_LITSEL_MAX',
   'OPT_NEG_LITSEL_MIN',
   'OPT_NEG_LITSEL_MAX',
   'OPT_ALL_LITSEL_MIN',
   'OPT_ALL_LITSEL_MAX',
   'OPT_WEIGHT_LITSEL_MIN',
   'OPT_PREFER_INITIAL_CLAUSES',
   'OPT_FILTER_LIMIT',
   'OPT_FILTER_COPIES_LIMIT',
   'OPT_REWEIGHT_LIMIT',
   'OPT_DELETE_BAD_LIMIT',
   'OPT_ASSUME_COMPLETENESS',
   'OPT_ASSUME_INCOMPLETENESS',
   'OPT_DISABLE_EQ_FACTORING',
   'OPT_DISABLE_NEGUNIT_PM',
   'OPT_CONDENSING',
   'OPT_CONDENSING_AGGRESSIVE',
   'OPT_NO_GC_FORWARD_SIMPL',
   'OPT_USE_SIM_PARAMOD',
   'OPT_USE_ORIENTED_SIM_PARAMOD',
   'OPT_SPLIT_TYPES',
   'OPT_SPLIT_HOW',
   'OPT_SPLIT_AGGRESSIVE',
   'OPT_SPLIT_REUSE_DEFS',
   'OPT_ORDERING',
   'OPT_TO_WEIGHTGEN',
   'OPT_TO_WEIGHTS',
   'OPT_TO_PRECGEN',
   'OPT_TO_CONSTWEIGHT',
   'OPT_TO_PRECEDENCE',
   'OPT_TO_LPO_RECLIMIT',
   'OPT_TO_RESTRICT_LIT_CMPS',
   'OPT_TPTP_SOS',
   'OPT_ER_DESTRUCTIVE',
   'OPT_ER_STRONG_DESTRUCTIVE',
   'OPT_ER_AGGRESSIVE',
   'OPT_FORWARD_CSR',
   'OPT_FORWARD_CSR_AGGRESSIVE',
   'OPT_BACKWARD_CSR',
   'OPT_RULES_GENERAL',
   'OPT_FORWARD_DEMOD',
   'OPT_STRONG_RHS_INSTANCE',
   'OPT_STRONGSUBSUMPTION',
   'OPT_WATCHLIST',
   'OPT_WATCHLIST_NO_SIMPLIFY',
   'OPT_NO_INDEXED_SUBSUMPTION',
   'OPT_FVINDEX_STYLE',
   'OPT_FVINDEX_FEATURETYPES',
   'OPT_FVINDEX_MAXFEATURES',
   'OPT_FVINDEX_SLACK',
   'OPT_RW_BW_INDEX',
   'OPT_PM_FROM_INDEX',
   'OPT_PM_INTO_INDEX',
   'OPT_FP_INDEX',
   'OPT_DETSORT_RW',
   'OPT_DETSORT_NEW',
   'OPT_DEFINE_WFUN',
   'OPT_DEFINE_HEURISTIC',
   'OPT_HEURISTIC',
   'OPT_FREE_NUMBERS',
   'OPT_FREE_OBJECTS',
   'OPT_OLD_STYLE_CNF',
   'OPT_DEF_CNF',
   'OPT_DUMMY'
] // OptionCodes [];

var OptionCodes = {}

typedef_enum_optionCodes.map(function(v)
{
    OptionCodes[v] = v
    return v
})

/*---------------------------------------------------------------------*/
/*                        Global Variables                             */
/*---------------------------------------------------------------------*/

// __import(cio_commandline.h)
var NoArg = 'NoArg'
var OptArg = 'OptArg'
var ReqArg = 'ReqArg'
var NULL = null
var FORMAT_WIDTH = 78

// __import(ccl_proofstate.h)
var WATCHLIST_INLINE_STRING = "Use inline watchlist type"
var WATCHLIST_INLINE_QSTRING = "WATCHLIST_INLINE_STRING"

// __import(ccl_tformulae.h)
var TFORM_RENAME_LIMIT = 24
var TFORM_RENAME_LIMIT_STR = "24"

// __import(che_clausesetfeatures.h)
var NGU_ABSOLUTE = true
var NGU_FEW_DEFAULT = 0.25
var NGU_MANY_DEFAULT = 0.75
var NGU_FEW_ABSDEFAULT = 1
var NGU_MANY_ABSDEFAULT = 3
var GPC_ABSOLUTE = true
var GPC_FEW_DEFAULT = 0.25
var GPC_MANY_DEFAULT = 0.75
var GPC_FEW_ABSDEFAULT = 1
var GPC_MANY_ABSDEFAULT = 3
var AX_1_DEFAULT = 10
var AX_4_DEFAULT = 15
var AX_SOME_DEFAULT = 20
var AX_MANY_DEFAULT = 100
var LIT_SOME_DEFAULT = 15
var LIT_MANY_DEFAULT = 100
var TERM_MED_DEFAULT = 60
var TERM_LARGE_DEFAULT = 1000
var FAR_SUM_MED_DEFAULT = 5
var FAR_SUM_LARGE_DEFAULT = 24
/*  Partitioning 2 way turns out to be nearly as good as 3 way on the test set */
var DEPTH_MEDIUM_DEFAULT = 0 
var DEPTH_DEEP_DEFAULT = 6
var SYMBOLS_MEDIUM_DEFAULT = 100
var SYMBOLS_LARGE_DEFAULT = 1000
var PREDC_MEDIUM_DEFAULT = 0
var PREDC_LARGE_DEFAULT = 2
var PRED_MEDIUM_DEFAULT = 1225
var PRED_LARGE_DEFAULT = 4000
var FUNC_MEDIUM_DEFAULT = 8
var FUNC_LARGE_DEFAULT = 110
var FUN_MEDIUM_DEFAULT = 360
var FUN_LARGE_DEFAULT = 400
var DEFAULT_OUTPUT_DESCRIPTOR = 'eigEIG'
var DEFAULT_CLASS_MASK = "aaaaaaaaaaaaa"

// __import(cco_forward_contraction.h)
var DEFAULT_FILTER_DESCRIPTOR = "Fc"

var opts = // OptCell
{
    'OPT_NOOPT':['','',0,0,''],    
    'OPT_HELP':['h', "help",NoArg,NULL,"Print a short description of program usage and options."],
    'OPT_VERSION':['V', "version",NoArg, NULL,"Print the version number of the prover. Please include this with all bug reports (if any)."],
    'OPT_VERBOSE':['v', "verbose",OptArg, "1","Verbose comments on the progress of the program. This differs from the output level (below) in that technical information is printed to stderr, while the output level determines which logical manipulations of the clauses are printed to stdout."],
    'OPT_OUTPUT':['o', "output-file",ReqArg, NULL,"Redirect output into the named file."],
    'OPT_SILENT':['s', "silent",NoArg, NULL,"Equivalent to --output-level=0."],
    'OPT_OUTPUTLEVEL':['l', "output-level",ReqArg, NULL,"Select an output level, greater values imply more verbose output. Level 0 produces nearly no output, level 1 will output each clause as it is processed, level 2 will output generating inferences, level 3 will give a full protocol including rewrite steps and level 4 will include some internal clause renamings. Levels >= 2 also imply PCL2 or TSTP formats (which can be post-processed with suitable tools)."],
    'OPT_PROOF_OBJECT':['p', "proof-object",OptArg, "1","Generate (and print, in case of success) an internal proof object. Level 0 will not build a proof object, level 1 will build a simple, compact proof object that only contains inference rules and dependencies, level 2 will build a proof object where inferences are unambiguously described by giving inference positions, and level 3 will expand this to a proof object where all intermediate results are explicit. This feature is under development, so far only level 0 and 1 are operational."], 
    'OPT_PCL_COMPRESSED':['\0', "pcl-terms-compressed",NoArg, NULL,"Print terms in the PCL output in shared representation."],
    'OPT_PCL_COMPACT':['\0', "pcl-compact",NoArg, NULL,"Print PCL steps without additional spaces for formatting (safes disk space for large protocols)."],
    'OPT_PCL_SHELL_LEVEL':['\0', "pcl-shell-level",OptArg, "1","Determines level to which clauses and formulas are suppressed in the output. Level 0 will print all, level 1 will only print initial clauses/formulas, level 2 will print no clauses or axioms. All levels will still print the dependency graph."],
    'OPT_PRINT_STATISTICS':['\0', "print-statistics",NoArg, NULL,"Print the inference statistics (only relevant for output level 0,otherwise they are printed automatically."],
    'OPT_EXPENSIVE_DETAILS':['0', "print-detailed-statistics",NoArg, NULL,"Print data about the proof state that is potentially expensive to collect. Includes number of term cells and number of rewrite steps."], 
    'OPT_PRINT_SATURATED':['S', "print-saturated",OptArg, DEFAULT_OUTPUT_DESCRIPTOR,"Print the (semi-) saturated clause sets after terminating the saturation process. The argument given describes which parts should be printed in which order. Legal characters are 'eigEIGaA', standing for processed positive units, processed negative units, processed non-units, unprocessed positive units, unprocessed negative units, unprocessed non-units, and two types of additional equality axioms, respectively. Equality axioms will only be printed if the original specification contained real equality. In this case, 'a' requests axioms in which a separate substitutivity axiom is given for each argument position of a function or predicate symbol, while 'A' requests a single substitutivity axiom (covering all positions) for each symbol."],  
    'OPT_PRINT_SAT_INFO':['\0', "print-sat-info",NoArg, NULL,"Print additional information (clause number, weight, etc) as a comment for clauses from the semi-saturated end system."],
    'OPT_FILTER_SATURATED':['\0', "filter-saturated",OptArg, DEFAULT_FILTER_DESCRIPTOR,"Filter the  (semi-) saturated clause sets after terminating the saturation process. The argument is a string describing which operations to take (and in which order). Options are 'u' (remove all clauses with more than one literal), 'c' (delete all but one copy of identical clauses, 'n', 'r', 'f' (forward contraction, unit-subsumption only, no rewriting, rewriting with rules only, full rewriting, respectively), and 'N', 'R' and 'F' (as their lower case counterparts, but with non-unit-subsumption enabled as well)."], 
    'OPT_PRUNE_ONLY':['\0', "prune",NoArg, NULL,"Stop after relevancy pruning, SInE pruning, and output of the initial clause- and formula set. This will automatically set output level to 4 so that the pruned problem specification is printed. Note that the desired pruning methods must still be specified (e.g. '--sine=Auto'"],
    'OPT_CNF_ONLY':['\0', "cnf",NoArg, NULL,"Convert the input problem into clause normal form and print it. This is (nearly) equivalent to '--print-saturated=eigEIG --processed-clauses-limit=0' and will by default perform some usually useful simplifications. You can additionally specify e.g. '--no-preprocessing' if you want just the result of CNF translation."],
    'OPT_PRINT_PID':['\0', "print-pid",NoArg, NULL,"Print the process id of the prover as a comment after option processing."],
    'OPT_PRINT_VERSION':['\0', "print-version",NoArg, NULL,"Print the version number of the prover as a comment after option processing. Note that unlike -version, the prover will not terminate, but proceed normally."],
    'OPT_REQUIRE_NONEMPTY':['\0', "error-on-empty",NoArg, NULL,"Return with an error code if the input file contains no clauses. Formally, the empty clause set (as an empty conjunction of clauses) is trivially satisfiable, and E will treat any empty input set as satisfiable. However, in composite systems this is more often a sign that something went wrong. Use this option to catch such bugs."],
    'OPT_MEM_LIMIT':['m', "memory-limit",ReqArg, NULL,"Limit the memory the prover may use. The argument is the allowed amount of memory in MB. If you use the argument 'Auto', the system will try to figure out the amount of physical memory of your machine and claim most of it. This option may not work everywhere, due to broken and/or strange behaviour of setrlimit() in some UNIX implementations, and due to the fact that I know of no portable way to figure out the physical memory in a machine. Both the option and the 'Auto' version do work under all tested versions of Solaris and GNU/Linux. Due to problems with limit data types, it is currently impossible to set a limit of more than 2 GB (2048 MB)."],
    'OPT_CPU_LIMIT':['\0', "cpu-limit",OptArg, "300","Limit the cpu time the prover should run. The optional argument is the CPU time in seconds. The prover will terminate immediately after reaching the time limit, regardless of internal state. This option may not work everywhere, due to broken and/or strange behaviour of setrlimit() in some UNIX implementations. It does work under all tested versions of Solaris, HP-UX, MacOS-X, and GNU/Linux. As a side effect, this option will inhibit core file writing. Please note that if you use both --cpu-limit and --soft-cpu-limit, the soft limit has to be smaller than the hard limit to have any effect. "], 
    'OPT_SOFTCPU_LIMIT':['\0', "soft-cpu-limit",OptArg, "290","Limit the cpu time the prover should spend in the main saturation phase. The prover will then terminate gracefully, i.e. it will perform post-processing, filtering and printing of unprocessed clauses, if these options are selected. Note that for some filtering options (in particular those which perform full subsumption), the post-processing time may well be larger than the saturation time. This option is particularly useful if you want to use E as a preprocessor or lemma generator in a larger system."],  
    'OPT_RUSAGE_INFO':['R', "resources-info",NoArg, NULL,"Give some information about the resources used by the prover. You will usually get CPU time information. On systems returning more information with the rusage() system call, you will also get information about memory consumption."],
    'OPT_STEP_LIMIT':['C', "processed-clauses-limit",ReqArg, NULL,"Set the maximal number of clauses to process (i.e. the number of traversals of the main-loop)."],
    'OPT_ANSWER_LIMIT':['\0', "answers",OptArg, "2147483647","Set the maximal number of answers to print for existentially quantified questions. Without this option, the prover terminates after the first answer found. If the value is different from 1, the prover is no longer guaranteed to terminate, even if there is a finite number of answers."],
    'OPT_CONJ_ARE_QUEST':['\0', "conjectures-are-questions",NoArg, NULL,"Treat all conjectures as questions to be answered. This is a wart necessary because CASC-J6 has categories requiring answers, but does not yet support the 'question' type for formulas."],
    'OPT_PROC_LIMIT':['P', "processed-set-limit",ReqArg, NULL,"Set the maximal size of the set of processed clauses. This differs from the previous option in that redundant and back-simplified processed clauses are not counted."],
    'OPT_UNPROC_LIMIT':['U', "unprocessed-limit",ReqArg, NULL,"Set the maximal size of the set of unprocessed clauses. This is a termination condition, not something to use to control the deletion of bad clauses. Compare --delete-bad-limit."],
    'OPT_TOTAL_LIMIT':['T', "total-clause-set-limit",ReqArg, NULL,"Set the maximal size of the set of all clauses. See previous option."],
    'OPT_NO_INFIX':['n', "eqn-no-infix",NoArg, NULL,"In LOP, print equations in prefix notation equal(x,y)."],
    'OPT_FULL_EQ_REP':['e', "full-equational-rep",NoArg, NULL,"In LOP. print all literals as equations, even non-equational ones."],
    'OPT_TPTP_PARSE':['\0', "tptp-in",NoArg, NULL,"Parse TPTP-2 format instead of E-LOP (but note that includes are handled according to TPTP-3 semantics)."],
    'OPT_TPTP_PRINT':['\0', "tptp-out",NoArg, NULL,"Print TPTP format instead of E-LOP. Implies --eqn-no-infix and will ignore --full-equational-rep."],
    'OPT_TPTP_FORMAT':['\0', "tptp-format",NoArg, NULL,"Equivalent to --tptp-in and --tptp-out."],
    'OPT_TPTP_PARSE':['\0', "tptp2-in",NoArg, NULL,"Synonymous with --tptp-in."],
    'OPT_TPTP_PRINT':['\0', "tptp2-out",NoArg, NULL,"Synonymous with --tptp-out."],
    'OPT_TPTP_FORMAT':['\0', "tptp2-format",NoArg, NULL,"Synonymous with --tptp-format."],
    'OPT_TSTP_PARSE':['\0', "tstp-in",NoArg, NULL,"Parse TPTP-3 format instead of E-LOP (Note that TPTP-3 syntax is still under development, and the version in E may not be fully conforming at all times. E works on all TPTP 3.0.1 input files (including includes)."],
    'OPT_TSTP_PRINT':['\0', "tstp-out",NoArg, NULL,"Print output clauses in TPTP-3 syntax. In particular, for output levels >=2, write derivations as TPTP-3 derivations (default is PCL)."],
    'OPT_TSTP_FORMAT':['\0', "tstp-format",NoArg, NULL,"Equivalent to --tstp-in and --tstp-out."],
    'OPT_TSTP_PARSE':['\0', "tptp3-in",NoArg, NULL,"Synonymous with --tstp-in."],
    'OPT_TSTP_PRINT':['\0', "tptp3-out",NoArg, NULL,"Synonymous with --tstp-out."],
    'OPT_TSTP_FORMAT':['\0', "tptp3-format",NoArg, NULL,"Synonymous with --tstp-format."],
    'OPT_AUTO':['\0', "auto",NoArg, NULL,"Automatically determine settings for proof search. This is equivalent to -xAuto -tAuto --sine=Auto."],
    'OPT_SATAUTO':['\0', "satauto",NoArg, NULL,"Automatically determine settings for proof/saturation search. This is equivalent to -xAuto -tAuto."],
    'OPT_AUTODEV':['\0', "autodev",NoArg, NULL,"Automatically determine settings for proof search (development version). This is equivalent to -xAutoDev -tAutoDev --sine=Auto."],
    'OPT_SATAUTODEV':['\0', "satautodev",NoArg, NULL,"Automatically determine settings for proof/saturation search (development version). This is equivalent to -xAutoDev -tAutoDev."],
    'OPT_AUTO_SCHED':['\0', "auto-schedule",NoArg, NULL,"Use the (experimental) strategy scheduling. This will try several different fully specified search strategies (aka \"Auto-Modes\"), one after the other, until a proof or saturation is found, or the time limit is exceeded."],
    'OPT_NO_PREPROCESSING':['\0', "no-preprocessing",NoArg, NULL,"Do not perform preprocessing on the initial clause set. Preprocessing currently removes tautologies and orders terms, literals and clauses in a certain (\"canonical\") way before anything else happens. Unless limited by one of the following options, it will also unfold equational definitions."],
    'OPT_EQ_UNFOLD_LIMIT':['\0', "eq-unfold-limit",ReqArg, NULL,"During preprocessing, limit unfolding (and removing) of equational definitions to those where the expanded definition is at most the given limit bigger (in terms of standard weight) than the defined term."],
    'OPT_EQ_UNFOLD_MAXCLAUSES':['\0', "eq-unfold-maxclauses",ReqArg, NULL,"During preprocessing, don't try unfolding of equational definitions if the problem has more than this limit of clauses."],
    'OPT_NO_EQ_UNFOLD':['\0', "no-eq-unfolding",NoArg, NULL,"During preprocessing, abstain from unfolding (and removing) equational definitions."],
    'OPT_SINE':['\0', "sine",OptArg, "Auto","Apply SInE to prune the unprocessed axioms with the specified filter. 'Auto' will automatically pick a filter."],
    'OPT_REL_PRUNE_LEVEL':['\0', "rel-pruning-level",OptArg, "3","Perform relevancy pruning up to the given level on the unprocessed axioms."],
    'OPT_PRESAT_SIMPLIY':['\0', "presat-simplify",NoArg, NULL,"Before proper saturation do a complete interreduction of the proof state."],
    'OPT_AC_HANDLING':['\0', "ac-handling",OptArg, "KeepUnits","Select AC handling mode. Preselected is 'DiscardAll', other options are 'None' to disable AC handling, 'KeepUnits', and 'KeepOrientable'."], 
    'OPT_AC_ON_PROC':['\0', "ac-non-aggressive",NoArg, NULL,"Do AC resolution on negative literals only on processing (by default, AC resolution is done after clause creation). Only effective if AC handling is not disabled."],
    'OPT_LITERAL_SELECT':['W', "literal-selection-strategy",ReqArg, NULL,"Choose a strategy for selection of negative literals. There are two special values for this option: NoSelection will select no literal (i.e. perform normal superposition) and NoGeneration will inhibit all generating inferences. For a list of the other (hopefully self-documenting) values run ''NAME' -W none'. There are two variants of each strategy. The one prefixed with 'P' will allow paramodulation into maximal positive literals in addition to paramodulation into maximal selected negative literals."],
    'OPT_NO_GENERATION':['\0', "no-generation",NoArg, NULL,"Don't perform any generating inferences (equivalent to --literal-selection-strategy=NoGeneration)."],
    'OPT_SELECT_ON_PROC_ONLY':['\0', "select-on-processing-only",NoArg, NULL,"Perform literal selection at processing time only (i.e. select only in the _given clause_), not before clause evaluation. This is relevant because many clause selection heuristics give special consideration to maximal or selected literals."],
    'OPT_INHERIT_PM_LIT':['i', "inherit-paramod-literals",NoArg, NULL,"Always select the negative literals a previous inference paramodulated into (if possible). If no such literal exists, select as dictated by the selection strategy."], 
    'OPT_INHERIT_GOAL_PM_LIT':['j', "inherit-goal-pm-literals",NoArg, NULL,"In a goal (all negative clause), always select the negative literals a previous inference paramodulated into (if possible). If no such literal exists, select as dictated by the selection strategy."], 
    'OPT_INHERIT_CONJ_PM_LIT':['j', "inherit-conjecture-pm-literals",NoArg, NULL,"In a conjecture-derived clause), always select the negative literals a previous inference paramodulated into (if possible). If no such literal exists, select as dictated by the selection strategy."],
    'OPT_POS_LITSEL_MIN':['\0', "selection-pos-min",ReqArg, NULL,"Set a lower limit for the number of positive literals a clause must have to be eligible for literal selection."],
    'OPT_POS_LITSEL_MAX':['\0', "selection-pos-max",ReqArg, NULL,"Set a upper limit for the number of positive literals a clause can have to be eligible for literal selection."],
    'OPT_NEG_LITSEL_MIN':['\0', "selection-neg-min",ReqArg, NULL,"Set a lower limit for the number of negative literals a clause must have to be eligible for literal selection."],
    'OPT_NEG_LITSEL_MAX':['\0', "selection-neg-max",ReqArg, NULL,"Set a upper limit for the number of negative literals a clause can have to be eligible for literal selection."],
    'OPT_ALL_LITSEL_MIN':['\0', "selection-all-min",ReqArg, NULL,"Set a lower limit for the number of literals a clause must have to be eligible for literal selection."],
    'OPT_ALL_LITSEL_MAX':['\0', "selection-all-max",ReqArg, NULL,"Set an upper limit for the number of literals a clause must have to be eligible for literal selection."],
    'OPT_WEIGHT_LITSEL_MIN':['\0', "selection-weight-min",ReqArg, NULL,"Set the minimum weight a clause must have to be eligible for literal selection."],
    'OPT_PREFER_INITIAL_CLAUSES':['\0', "prefer-initial-clauses",NoArg, NULL,"Always process all initial clauses first."],
    'OPT_HEURISTIC':['x', "expert-heuristic",ReqArg, NULL,"Select one of the clause selection heuristics. Currently at least available: Auto, Weight, StandardWeight, RWeight, FIFO, LIFO, Uniq, UseWatchlist. For a full list check HEURISTICS/che_proofcontrol.c. Auto is recommended if you only want to find a proof. It is special in that it will also set some additional options. To have optimal performance, you also should specify -tAuto to select a good term ordering. LIFO is unfair and will make the prover incomplete. Uniq is used internally and is not very useful in most cases. You can define more heuristics using the option -H (see below)."],
    'OPT_FILTER_LIMIT':['\0', "filter-limit",OptArg, "1000000","Set the limit on the number of 'storage units' in the proof state, after which the set of unprocessed clauses will be filtered against the processed clauses to eliminate redundant clauses. As of E 0.7, a 'storage unit' is approximately one byte, however, storage is estimated in an abstract way, independent of hardware or memory allocation library, and the storage estimate is only an approximation."],
    'OPT_FILTER_COPIES_LIMIT':['\0', "filter-copies-limit",OptArg, "800000","Set the number of storage units in new unprocessed clauses after which the set of unprocessed clauses will be filtered for equivalent copies of clauses (see above). As this operation is cheaper, you may want to set this limit lower than --filter-limit."],
    'OPT_DELETE_BAD_LIMIT':['\0', "delete-bad-limit",OptArg, "1500000","Set the number of storage units after which bad clauses are deleted without further consideration. This causes the prover to be potentially incomplete, but will allow you to limit the maximum amount of memory used fairly well. The prover will tell you if a proof attempt failed due to the incompleteness introduced by this option. It is recommended to set this limit significantly higher than --filter-limit or --filter-copies-limit. If you select -xAuto and set a memory limit, the prover will determine a good value automatically."], 
    'OPT_ASSUME_COMPLETENESS':['\0', "assume-completeness",NoArg, NULL,"There are various way (e.g. the next few options) to configure the prover to be strongly incomplete in the general case. E will detect when such an option is selected and return corresponding exit states (i.e. it will not claim satisfiability just because it ran out of unprocessed clauses). If you _know_ that for your class of problems the selected strategy is still complete, use this option to tell the system that this is the case."],
    'OPT_ASSUME_INCOMPLETENESS':['\0', "assume-incompleteness",NoArg, NULL,"This option instructs the prover to assume incompleteness (typically because the axiomatization already is incomplete because axioms have been filtered before they are handed to the system."],
    'OPT_DISABLE_EQ_FACTORING':['\0', "disable-eq-factoring",NoArg, NULL,"Disable equality factoring. This makes the prover incomplete for general non-Horn problems, but helps for some specialized classes. It is not necessary to disable equality factoring for Horn problems, as Horn clauses are not factored anyways."], 
    'OPT_DISABLE_NEGUNIT_PM':['\0', "disable-paramod-into-neg-units",NoArg, NULL,"Disable paramodulation into negative unit clause. This makes the prover incomplete in the general case, but helps for some specialized classes."], 
    'OPT_CONDENSING':['\0', "condense",NoArg, NULL,"Enable condensing for the given clause. Condensing replaces a clause by a more general factor (if such a factor exists)."], 
    'OPT_CONDENSING_AGGRESSIVE':['\0', "condense-aggressive",NoArg, NULL,"Enable condensing for the given and newly generated clauses."], 
    'OPT_NO_GC_FORWARD_SIMPL':['\0', "disable-given-clause-fw-contraction",NoArg, NULL,"Disable simplification and subsumption of the newly selected given clause (clauses are still simplified when they are generated). In general, this breaks some basic assumptions of the DISCOUNT loop proof search procedure. However, there are some problem classes in which  this simplifications empirically never occurs. In such cases, we can save significant overhead. The option _should_ work in all cases, but is not expected to improve things in most cases."],
    'OPT_USE_SIM_PARAMOD':['\0', "simul-paramod",NoArg, NULL,"Use simultaneous paramodulation to implement superposition. Default is to use plain paramodulation. This is an experimental feature."],
    'OPT_USE_ORIENTED_SIM_PARAMOD':['\0', "oriented-simul-paramod",NoArg, NULL,"Use simultaneous paramodulation for oriented from-literals. This is an experimental feature."], 
    'OPT_SPLIT_TYPES':['\0', "split-clauses",OptArg, "7","Determine which clauses should be subject to splitting. The argument is the binary 'OR' of values for the desired classes:\n     1:  Horn clauses\n     2:  Non-Horn clauses\n     4:  Negative clauses\n     8:  Positive clauses\n    16:  Clauses with both positive and negative literals\nEach set bit adds that class to the set of clauses which will be split."],
    'OPT_SPLIT_HOW':['\0' , "split-method",ReqArg, NULL,"Determine how to treat ground literals in splitting. The argument is either '0' to denote no splitting of ground literals (they are all assigned to the first split clause produced), '1' to denote that all ground literals should form a single new clause, or '2', in which case ground literals are treated as usual and are all split off into individual clauses."],
    'OPT_SPLIT_AGGRESSIVE':['\0', "split-aggressive",NoArg, NULL,"Apply splitting to new clauses (after simplification) and before evaluation. By default, splitting (if activated) is only performed on selected clauses. "],
    'OPT_SPLIT_REUSE_DEFS':['\0', "split-reuse-defs",NoArg, NULL,"If possible, reuse previous definitions for splitting."],
    'OPT_REWEIGHT_LIMIT':['\0', "reweight-limit",OptArg, "30000","Set the number of new unprocessed clauses after which the set of unprocessed clauses will be reevaluated."],
    'OPT_ORDERING':['t', "term-ordering",ReqArg, NULL,"Select an ordering type (currently Auto, LPO, LPO4, KBO or KBO6). -tAuto is suggested, in particular with -xAuto. KBO and KBO1 are different implementations of the same ordering, KBO is usually faster and has had more testing. Similarly, LPO4 is an new, equivalent but superior implementation of LPO."],
    'OPT_TO_WEIGHTGEN':['w', "order-weight-generation",ReqArg, NULL,"Select a method for the generation of weights for use with the term ordering. Run '\" NAME \" -w none' for a list of options."],
    'OPT_TO_WEIGHTS':['\0', "order-weights",ReqArg, NULL,"Describe a (partial) assignments of weights to function symbols for term orderings (in particular, KBO). You can specify a list of weights of the form 'f1:w1,f2:w2, ...'. Since a total weight assignment is needed, E will _first_ apply any weight generation scheme specified (or the default one), and then modify the weights as specified. Note that E performs only very basic sanity checks, so you probably can specify weights that break KBO constraints."],
    'OPT_TO_PRECGEN':['G', "order-precedence-generation",ReqArg, NULL,"Select a method for the generation of a precedence for use with the term ordering. Run '\" NAME \" -G none' for a list of options."], 
    'OPT_TO_CONSTWEIGHT':['c', "order-constant-weight",ReqArg, NULL,"Set a special weight > 0 for constants in the term ordering. By default, constants are treated like other function symbols."],
    'OPT_TO_PRECEDENCE':['\0', "precedence",OptArg, "","Describe a (partial) precedence for the term ordering used for the proof attempt. You can specify a comma-separated list of precedence chains, where a precedence chain is a list of function symbols (which all have to appear in the proof problem), connected by >, <, or =. If this option is used in connection with --order-precedence-generation, the partial ordering will be completed using the selected method, otherwise the prover runs with a non-ground-total ordering."],
    'OPT_TO_LPO_RECLIMIT':['\0', "lpo-recursion-limit",OptArg, "100","Set a depth limit for LPO comparisons. Most comparisons do not need more than 10 or 20 levels of recursion. By default, recursion depth is limited to 1000 to avoid stack overflow problems. If the limit is reached, the prover assumes that the terms are uncomparable. Smaller values make the comparison attempts faster, but less exact. Larger values have the opposite effect. Values up to 20000 should be save on most operating systems. If you run into segmentation faults while using LPO or LPO4, first try to set this limit to a reasonable value. If the problem persists, send a bug report ;-)"],
    'OPT_TO_RESTRICT_LIT_CMPS':['\0', "restrict-literal-comparisons",NoArg, NULL,"Make all literals uncomparable in the term ordering (i.e. do not use the term ordering to restrict paramodulation, equality resolution and factoring to certain literals. This is necessary to make Set-of-Support-strategies complete for the non-equational case (It still is incomplete for the equational case, but pretty useless anyways)."],
    'OPT_TPTP_SOS':['\0', "sos-uses-input-types",NoArg, NULL,"If input is TPTP format, use TPTP conjectures for initializing the Set of Support. If not in TPTP format, use E-LOP queries (clauses of the form ?-l(X),...,m(Y)). Normally, all negative clauses are used. Please note that most E heuristics do not use this information at all, it is currently only useful for certain parameter settings (including the SimulateSOS priority function)."],
    'OPT_ER_DESTRUCTIVE':['\0', "destructive-er",NoArg, NULL,"Allow destructive equality resolution inferences on pure-variable literals of the form X!=Y, i.e. replace the original clause with the result of an equality resolution inference on this literal."], 
    'OPT_ER_STRONG_DESTRUCTIVE':['\0', "strong-destructive-er",NoArg, NULL,"Allow destructive equality resolution inferences on literals of the form X!=t (where X does not occur in t), i.e. replace the original clause with the result of an equality resolution inference on this literal. Unless I am brain-dead, this maintains completeness, although the proof is rather tricky."], 
    'OPT_ER_AGGRESSIVE':['\0', "destructive-er-aggressive",NoArg, NULL,"Apply destructive equality resolution to all newly generated clauses, not just to selected clauses. Implies --destructive-er."],
    'OPT_FORWARD_CSR':['\0', "forward-context-sr",NoArg, NULL,"Apply contextual simplify-reflect with processed clauses to the given clause."],
    'OPT_FORWARD_CSR_AGGRESSIVE':['\0', "forward-context-sr-aggressive",NoArg, NULL,"Apply contextual simplify-reflect with processed clauses to new clauses. Implies --forward-context-sr."],
    'OPT_BACKWARD_CSR':['\0', "backward-context-sr",NoArg, NULL,"Apply contextual simplify-reflect with the given clause to processed clauses."],
    'OPT_RULES_GENERAL':['g', "prefer-general-demodulators",NoArg, NULL,"Prefer general demodulators. By default, E prefers specialized demodulators. This affects in which order the rewrite  index is traversed."], 
    'OPT_FORWARD_DEMOD':['F', "forward_demod_level",ReqArg, NULL,"Set the desired level for rewriting of unprocessed clauses. A value of 0 means no rewriting, 1 indicates to use rules (orientable equations) only, 2 indicates full rewriting with rules and instances of unorientable equations. Default behavior is 2."],
    'OPT_STRONG_RHS_INSTANCE':['\0', "strong-rw-inst",NoArg, NULL,"Instantiate unbound variables in matching potential demodulators with a small constant terms."],
    'OPT_STRONGSUBSUMPTION':['u', "strong-forward-subsumption",NoArg, NULL,"Try multiple positions and unit-equations to try to equationally subsume a single new clause. Default is to search for a single position."],
    'OPT_WATCHLIST':['\0', "watchlist",OptArg, WATCHLIST_INLINE_QSTRING,"Give the name for a file containing clauses to be watched for during the saturation process. If a clause is generated that subsumes a watchlist clause, the subsumed clause is removed from the watchlist. The prover will terminate when the watchlist is empty. If you want to use the watchlist for guiding the proof, put the empty clause onto the list and use the built-in clause selection heuristic 'UseWatchlist' (or build a heuristic yourself using the priority functions 'PreferWatchlist' and 'DeferWatchlist'). Use the argument \" WATCHLIST_INLINE_QSTRING \" (or no argument) and the special clause type 'watchlist' if you want to put watchlist clauses into the normal input stream. This is only supported for TPTP input formats."], 
    'OPT_WATCHLIST_NO_SIMPLIFY':['\0', "no-watchlist-simplification",NoArg, NULL,"Normally, that watchlist is brought into normal form with respect to the current processed clause set and certain simplifications. This option disables this behaviour."],
    'OPT_NO_INDEXED_SUBSUMPTION':['\0', "conventional-subsumption",NoArg, NULL,"Equivalent to --subsumption-indexing=None."],
    'OPT_FVINDEX_STYLE':['\0', "subsumption-indexing",ReqArg, NULL,"Determine choice of indexing for (most) subsumption operations. Choices are 'None' for naive subsumption, 'Direct' for direct mapped FV-Indexing, 'Perm' for permuted FV-Indexing and 'PermOpt' for permuted FV-Indexing with deletion of (suspected) non-informative features. Default behaviour is 'Perm'."],
    'OPT_FVINDEX_FEATURETYPES':['\0', "fvindex-featuretypes",ReqArg, NULL,"Select the feature types used for indexing. Choices are \"None\" to disable FV-indexing, \"AC\" for AC compatible features (the default) (literal number and symbol counts), \"SS\" for set subsumption compatible features (symbol depth), and \"All\" for all features.Unless you want to measure the effects of the different features, I suggest you stick with the default."],
    'OPT_FVINDEX_MAXFEATURES':['\0', "fvindex-maxfeatures",OptArg, "200","Set the maximum initial number of symbols for feature computation. Depending on the feature selection, a value of X here will convert into 2X+2 features (for set subsumption features), 2X+4 features (for AC-compatible features) or 4X+6 features (if all features are used, the default). Note that the actually used set of features may be smaller than this if the signature does not contain enough symbols.For the Perm and PermOpt version, this is _also_ used to set the maximum depth of the feature vector index. Yes, I should probably make this into two separate options. If you select a small value here, you should probably not use \"Direct\" for the --subsumption-indexing option."],
    'OPT_FVINDEX_SLACK':['\0', "fvindex-slack",OptArg, "0","Set the number of slots reserved in the index for function symbols that may be introduced into the signature later, e.g. by splitting. If no new symbols are introduced, this just wastes time and memory. If PermOpt is chosen, the slackness slots will be deleted from the index anyways, but will still waste (a little) time in computing feature vectors."],
    'OPT_RW_BW_INDEX':['\0', "rw-bw-index",OptArg, "FP7","Select fingerprint function for backwards rewrite index. \"NoIndex\" will disable paramodulation indexing. For a list of the other values run '\" NAME \" --pm-index=none'. FPX functionswill use a fingerprint of X positions, the letters disambiguate between different fingerprints with the same sample size."],
    'OPT_PM_FROM_INDEX':['\0', "pm-from-index",OptArg, "FP7","Select fingerprint function for the index for paramodulation from indexed clauses. \"NoIndex\" will disable paramodulation indexing. For a list of the other values run '\" NAME \" --pm-index=none'. FPX functionswill use a fingerprint of X positions, the letters disambiguate between different fingerprints with the same sample size."],
    'OPT_PM_INTO_INDEX':['\0', "pm-into-index",OptArg, "FP7","Select fingerprint function for the index for paramodulation into the indexed clauses. \"NoIndex\" will disable paramodulation indexing. For a list of the other values run '\" NAME \" --pm-index=none'. FPX functionswill use a fingerprint of X positions, the letters disambiguate between different fingerprints with the same sample size."],
    'OPT_FP_INDEX':['\0', "fp-index",OptArg, "FP7","Select fingerprint function for all fingerprint indices. See above."],  
    'OPT_DETSORT_RW':['\0', "detsort-rw",NoArg, NULL,"Sort set of clauses eliminated by backward rewriting using a total syntactic ordering."],
    'OPT_DETSORT_NEW':['\0', "detsort-new",NoArg, NULL,"Sort set of newly generated and backward simplified clauses using a total syntactic ordering."],
    'OPT_DEFINE_WFUN':['D', "define-weight-function",ReqArg, NULL,"Define  a weight function (see manual for details). Later definitions override previous definitions."],
    'OPT_DEFINE_HEURISTIC':['H', "define-heuristic",ReqArg, NULL,"Define a clause selection heuristic (see manual for details). Later definitions override previous definitions."], 
    'OPT_FREE_NUMBERS':['\0', "free-numbers", NoArg, NULL, "Treat numbers (strings of decimal digits) as normal free function symbols in the input. By default, number now are supposed to denote domain constants and to be implicitly different from each other."], 
    'OPT_FREE_OBJECTS':['\0', "free-objects", NoArg, NULL, "Treat object identifiers (strings in double quotes) as normal free function symbols in the input. By default, object identifiers now represent domain objects and are implicitly different from each other (and from numbers, unless those are declared to be free)."], 
    'OPT_DEF_CNF':['\0', "definitional-cnf",OptArg, TFORM_RENAME_LIMIT_STR,"Tune the clausification algorithm to introduces definitions for subformulae to avoid exponential blow-up. The optional argument is a fudge factor that determines when definitions are introduced. 0 disables definitions completely. The default works well."],
    'OPT_DUMMY':['\0', NULL,NoArg, NULL,NULL]
}

// __import(clb_defines.h)
// typedef union int_or_p
function int_or_p()
{
   function obj()
   {
      this.i_val;
      this.p_val;
   }
   return obj
}
var IntOrP = int_or_p();

// __import(clb_pstacks.h)
// typedef int PStackPointer
function PStackPointer()
{
   this.value
}

function pstackcell()
{
   function obj()
   {
      this.size;    /* allocated memory */
      this.current = new PStackPointer(); /* First unused address, 0 for empty stack */  
      this.stack =  new IntOrP();  /* Stack area */
   }
   return obj
}
var PStackCell = pstackcell()
var PStack_p = pstackcell()

// __import(clb_stringtrees.h)
function strtreecell()
{
   function obj()
   {
      this.key;
      this.val1 = new IntOrP();
      this.val2 = new IntOrP();
      this.lson = {};
      this.rson = {};
   }
   return obj
}
var StrTreeCell = strtreecell()
var StrTree_p = strtreecell()

// __import(cpr_propsig.h)
function propsigcell()
{
   function obj()
   {
      this.enc_to_name = new PStack_p();
      this.name_to_enc = new StrTree_p();
   }
   return obj
}
var PropSigCell = propsigcell()
var PropSig_p = propsigcell();
var PLiteralCode;

// __import(cte_signature.h)
function typedef_enum_funcprop()
{
   function obj()
   {
      this.FPIgnoreProps  =    0 /* No properties, mask everything out */
      this.FPPredSymbol   =    1 /* Symbol is a transformed predicate symbol */
      this.FPFuncSymbol   =    2 /* Symbol is a real function symbol */
      /* If neither is set, we don't know it yet */
      this.FPFOFOp        =    4 /* Symbol is encoded first order operator */
      this.FPSpecial      =    8 /* Symbol is a special symbol introduced internally */
      this.FPAssociative  =   16 /* Function symbol is binary and associative */
      this.FPCommutative  =   32 /* Function symbol is binary and commutates */
      this.FPIsAC         =   this.FPAssociative|this.FPCommutative,
      this.FPInterpreted  =   64 /* Interpreted symbol $ident */
      this.FPIsInteger    =  128 /* Sequence of digits, may be semi-interpreted */
      this.FPIsRational   =  256 /* [-]a/b */
      this.FPIsFloat      =  512 /* Floating point number */
      this.FPIsObject     =  1024 /* ""-enclosed string, by definition denotes unique object." */
      this.FPDistinctProp =  this.FPIsObject | this.FPIsInteger | this.FPIsRational | this.FPIsFloat
      this.FPOpFlag       = 2048 /* Used for temporary oerations, by defintion off if not in use! */
      this.FPClSplitDef   = 4096 /* Predicate is a clause split defined symbol. */
      this.FPPseudoPred   = 8192  /* Pseudo-predicate used for side effects only, does not conceptually contribute to truth of clause */
   }
   return obj
}
var FunctionProperties = typedef_enum_funcprop()

// __import(cte_signature.h)
function funccell()
{
   function obj()
   {
      /* f_code is implicit by position in the array */
      this.name;
      this.arity;
      this.alpha_rank; /* We sometimes need an arbitrary but stable order on symbols and use alphabetic. */
      this.properties = new FunctionProperties();
   }
   return obj
}
var FuncCell = funccell()
var Func_p = funccell()

var DEFAULT_SIGNATURE_SIZE = 20
var DEFAULT_SIGNATURE_GROW = 2

// __import(clb_pdarrays.h)
function pdarraycell()
{
   function obj()
   {
      this.integer; 
      this.size;
      this.grow;
      this.array = new IntOrP();
   }
   return obj
}
var PDArrayCell = pdarraycell()
var PDArray_p = pdarraycell()

// __import(cte_functypes.h)
/* Function symbols in terms are represented by positive numbers,
   variables by negative numbers. This alias allows clearer
   specifications. */

// typedef long FunCode;
function FunCode()
{
   this.value = arguments[0] || 0
}

function sigcell()
{
   function obj()
   {
      this.alpha_ranks_valid; /* The alpha-ranks are up to date */
      this.size;     /* Size of the array */
      this.f_info = new Func_p();   /* The array */
      this.orn_codes = new PDArray_p();
      this.f_index = new StrTree_p();  /* Back-assoc: Given a symbol, get the index */
      this.ac_axioms = new PStack_p(); /* All recognized AC axioms */
      /* The following are special symbols needed for pattern
         manipulation. We want very efficient access to them! Also
         resused in FOF parsing. */
      this.f_count = new FunCode();  /* Largest used f_code */
      this.internal_symbols = new FunCode(); /* Largest auto-inserted internal symbol */
      this.eqn_code = new FunCode();
      this.neqn_code = new FunCode();
      this.cnil_code = new FunCode();

      /* The following is for encoding first order formulae as terms. I
         do like to reuse the robust sharing infrastructure for
         CNFization and formula rewriting (inspired by Tommi Juntilla's
         reuse of the same in MathSAT). */      
      this.not_code = new FunCode();
      this.qex_code = new FunCode();
      this.qall_code = new FunCode();
      this.and_code = new FunCode();
      this.or_code = new FunCode();
      this.impl_code = new FunCode();
      this.equiv_code = new FunCode();
      this.nand_code = new FunCode();
      this.nor_code = new FunCode();
      this.bimpl_code = new FunCode();
      this.xor_code = new FunCode();
      /* And here are codes for interpreted symbols */
      this.answer_code = new FunCode();       /* For answer literals */
      
      /* Counters for generating new symbols */
      this.skolem_count;
      this.newpred_count;
      /* Which properties are used for recognizing implicit distinctness? */
      this.distinct_props = new FunctionProperties ();
   }
   return obj
}
var SigCell = sigcell()
var Sig_p = sigcell()

// __import(clb_sysdate.h)
// typedef long SysDate
function SysDate()
{
   this.value = arguments[0] || 0
}

// __import(cte_termvars.h)
/* Variable banks store information about variables. They contain two
   indices, one associating an external variable name with an internal
   term cell (and f_code, just because a StrTree can store two data
   items...), and one associating an f_code with a term cell. The first
   index is used for parsing and may be incomplete (i.e. not all
   variable cells will be indexed by a string), the second index
   should be complete (i.e. all variable cells have an entry in the
   array). */

function varbankcell()
{
   function obj()
   {
      this.v_count = new FunCode();      /* FunCode counter for new variables */
      this.max_var = new FunCode();      /* Largest variable ever created */
      this.ext_index = new StrTree_p();    /* Associate names and cells */
      this.f_code_index = new PDArray_p(); /* Associate FunCodes and cells */
   }
   return obj
}
var VarBankCell = varbankcell()
var VarBank_p = varbankcell()

// __import(ccl_eqn.h)
function typedef_enum_eqnproperties()
{
   function obj()
   {
      this.EPNoProps           =     0 /* No properties set or selected */
      this.EPIsPositive        =     1 /* s=t (as opposed to s!=t) */
      this.EPIsMaximal         =     2 /* Eqn is maximal in a clause */
      this.EPIsStrictlyMaximal =     4 /* Eqn is strictly maximal */
      this.EPIsEquLiteral      =     8 /* s=t not s=$true */
      this.EPIsOriented        =    16 /* s=>t  or s=t ? */
      this.EPMaxIsUpToDate     =    32 /* Orientation status is up to date */
      this.EPHasEquiv          =    64 /* Literal has been used in
                                          multiset-comparison (and found an
                                          equivalent partner) */ 
      this.EPIsDominated       =   128 /* Literal is dominated by another one */
      this.EPDominates         =   this.EPIsDominated /* Double use of this property
                                                         in potentially maximal or
                                                         minimal clauses */
      this.EPIsUsed            =   256 /* For non-injective subsumption and pattern-generation */
      this.EPGONatural         =   512 /* Set if left-side is bigger in the
                                          special (total) ground-ordering,
                                          treating variables as small
                                          constants */
      this.EPIsSelected        =  1024 /* For selective superpostion */
      this.EPIsPMIntoLit       =  2048 /* For inheriting selection */
      this.EPFromClauseLit     =  4096 /* This comes from the from clause in
                                      a paramod stthis.EP */
      this.EPPseudoLit         =  8192 /* This is a pseudo-literal that does
                                          not contribute to the semantic
                                          evaluation of the clause. */
      this.EPLPatMinimal       = 16384 /* Eqn l=r is Pattern-Minimal */
      this.EPRPatMinimal       = 32768 /* Eqn r=l is Pattern-Minimal */
      this.EPIsSplitLit        = 65636  /* This literal has been introduced by splitting */
   }
   return obj
}
var EqnProperties = typedef_enum_eqnproperties()

/* Basic data structure for rules, equations, literals. Terms are
   always assumed to be shared and need to be manipulated while 
   accounting for references! */ 

function typedef_struct_eqncell()
{
   function obj()
   {
      this.properties = new EqnProperties();   /* Positive, maximal, equational */
      this.lterm = {} // new Term_p();
      this.rterm = {} // new Term_p();
      this.pos;
      this.bank = {} // new TB_p();  /* Terms are from this bank */
      this.next = {};          /* For lists of equations */
   }
   return obj
}
var EqnCell = typedef_struct_eqncell()
var Eqn_p = typedef_struct_eqncell()
var EqnRef = typedef_struct_eqncell()

// __import(ccl_neweval.h)
function typedef_long_evalpriority()
{
   function obj(v)
   {
      this.value = v || 0
   }
   return obj
}
var EvalPriority = typedef_long_evalpriority()

var PrioBest = 0
var PrioPrefer = 30
var PrioNormal = 40
var PrioDefer = 50
var PrioLargestReasonable = MEGA

function typedef_struct_simple_eval_cell()
{
   function obj()
   {
      this.priority =  new EvalPriority();   /* Technical considerations */
      this.heuristic;  /* Heuristical evaluation   */
      this.lson = {} // struct eval_cell*;       /* Successors in ordered tree */
      this.rson = {} // struct eval_cell*;
   }
   return obj
}
var SimpleEvalCell = typedef_struct_simple_eval_cell()
var SimpleEval_p = typedef_struct_simple_eval_cell()

function typedef_struct_eval_cell()
{
   function obj()
   {
      this.eval_no;    /* Number of simple evaluations */
      this.eval_count; /* Evaluation cell count, used as FIFO tiebreaker */
      this.object = {};     /* Evaluated object.*/
      this.evals = [new SimpleEvalCell()];
   }
   return obj
}
EvalCell = typedef_struct_eval_cell()
Eval_p = typedef_struct_eval_cell()

// __import(ccl_clauses.h)
/*---------------------------------------------------------------------*/
/*                    Data type declarations                           */
/*---------------------------------------------------------------------*/

function typedef_enum_clauseproperties()
{
   function obj()
   {
      this.CPIgnoreProps       = 0                      /* For masking properties out */ 
      this.CPInitial           = 1                      /* Initial clause */
      this.CPInputClause       = 2*this.CPInitial       /* _Really_ initial clause in TSTP sense */ 
      this.CPIsProcessed       = 2*this.CPInputClause   /* Clause has been processed previously */ 
      this.CPIsOriented        = 2*this.CPIsProcessed   /* Term and literal
                                                           comparisons are up to
                                                           date */
      this.CPIsDIndexed        = 2*this.CPIsOriented    /* Clause is in the demod_index of its set */ 
      this.CPIsSIndexed        = 2*this.CPIsDIndexed    /* Clause is in the fvindex of its set */ 
      this.CPIsGlobalIndexed   = 2*this.CPIsSIndexed    /* Clause is in the Subterm FPIndex  */
      this.CPRWDetected        = 2*this.CPIsGlobalIndexed   /* Rewritability of the
                                                               clause has been
                                                               established. Temporary
                                                               property. */
      this.CPDeleteClause      = 2*this.CPRWDetected        /* Clause should be deleted for some reason */ 
      this.CPType1             = 2*this.CPDeleteClause      /* Three bits used to encode
                                                               the Clause type taken
                                                               from TPTP or  TSTP input
                                                               format or assumed */
      this.CPType2             = 2*this.CPType1        
      this.CPType3             = 2*this.CPType2       
      this.CPTypeMask          = this.CPType1|this.CPType2|this.CPType3
      this.CPTypeUnknown       = 0                      /* Also used as wildcard */
      this.CPTypeAxiom         = this.CPType1           /* Clause is Axiom */
      this.CPTypeHypothesis    = this.CPType2           /* Clause is Hypothesis */
      this.CPTypeConjecture    = this.CPType1|this.CPType2 /* Clause is Conjecture */
      this.CPTypeLemma         = this.CPType3               /* Clause is Lemma */
      this.CPTypeNegConjecture = this.CPType1|this.CPType3  /* Clause is an negated
                                                               conjecture (used for
                                                               refutation) */
      this.CPTypeQuestion      = this.CPType2|this.CPType3  /* Clause is a question -
                                                               only used for FOF really. */
      this.CPTypeWatchClause   = this.CPType1|this.CPType2|this.CPType3
                                                      /* Clause is intended as a
                                                         watch list clause */
      this.CPIsIRVictim        = 2*this.CPType3       /* Clause has just been
                                                         simplified in
                                                         interreduction */ 
      this.CPOpFlag            = 2*this.CPIsIRVictim  /* Temporary marker */
      this.CPIsSelected        = 2*this.CPOpFlag      /* For analysis of selected
                                                         clauses only */ 
      this.CPIsFinal           = 2*this.CPIsSelected  /* Clause is a final clause
                                                         i.e. a clause that
                                                         might be used by a
                                                         postprocessor. */ 
      this.CPIsProofClause  = 2*this.CPIsFinal        /* Clause is part of a successful proof. */
      this.CPIsSOS          = 2*this.CPIsProofClause  /* Clause is in the set of support.*/
      this.CPNoGeneration   = 2*this.CPIsSOS          /* No generating inferences
                                                         with this clause are
                                                         necessary */
      this.CP_CSSCPA_1      = 2*this.CPNoGeneration   /* CSSCPA clause sources */
      this.CP_CSSCPA_2      = 2*this.CP_CSSCPA_1 
      this.CP_CSSCPA_4      = 2*this.CP_CSSCPA_2 
      this.CP_CSSCPA_8      = 2*this.CP_CSSCPA_4
      this.CP_CSSCPA_Mask   = this.CP_CSSCPA_1|this.CP_CSSCPA_2|this.CP_CSSCPA_4|this.CP_CSSCPA_8
      this.CP_CSSCPA_Unkown = 0
      this.CPIsProtected    = 2*this.CP_CSSCPA_8      /* Unprocessed clause has
                                                         been used in
                                                         simplification and cannot
                                                         be deleted even if
                                                         parents die. */
      this.CPWatchOnly      = 2*this.CPIsProtected
      this.CPSubsumesWatch  = 2*this.CPWatchOnly
      this.CPLimitedRW      = 2*this.CPSubsumesWatch  /* Clause has been processed
                                                         and hence can only be
                                                         rewritten in limited
                                                         ways. */
      this.CPIsRelevant     = 2*this.CPLimitedRW      /* Clause is selected as
                                                         relevant for a proof
                                                         attempt. */
   } // obj {}
   return obj
}
var ClauseProperties = typedef_enum_clauseproperties()

// __import(ccl_clauseinfo.h)
function typedef_struct_clause_info_cell()
{
   function obj()
   {
      this.name;   /* In the input file, if any */
      this.source; /* File name, if any */
      this.line;
      this.column;
   }
   return obj
}
var ClauseInfoCell = typedef_struct_clause_info_cell()
var ClauseInfo_p = typedef_struct_clause_info_cell()

// __import(clb_ptrees.h)
/* Data structure for indexing pointers (which need to be casted
   carefully by the wrapper functions). The key comes last in the
   struct to circumvent some bug in various gcc versions (apparently,
   gcc likes to safe a variable and will not always allocate a
   temporary variable when it thinks it can reuse the original
   position. In this case, it is wrong (exhibited in
   PTreeExtractKey()). Moving key to the back works around it (the
   memory management module will overwrite just the first word...) */ 

function typedef_struct_ptreecell()
{
   function obj()
   {
      this.lson = {} // struct ptreecell *;
      this.rson = {} // struct ptreecell *;
      this.key = {} // void*;
   }
   return obj
}
var PTreeCell = typedef_struct_ptreecell()
var PTree_p = typedef_struct_ptreecell()

function typedef_struct_clause_cell()
{
   function obj()
   {
      this.ident;       /* Hopefully unique ident for
                        all clauses created during
                        proof run */
   if(CLAUSE_PERM_IDENT){
      this.perm_ident;  /* Running number, given on alloc, never modified */
   }
      this.date = new SysDate();        /* ...at which this clause became a demodulator */
      this.literals = new Eqn_p();    /* List of literals */
      this.neg_lit_no;  /* Negative literals */
      this.pos_lit_no;  /* Positive literals */
      this.weight;      /* ClauseStandardWeight()
                        precomputed at some points in
                        the program */
      this.evaluations = new Eval_p(); /* List of evaluations */
      this.properties = new ClauseProperties();  /* Anything we want to note at he clause? */
      this.info = ClauseInfo_p();        /* Currently about source in input, NULL for derived clauses */
      this.derivation = new PStack_p();  /* Derivation of the clause for proof reconstruction. */
      this.create_date; /* At what iteration of the
                        main loop has this
                        clause been created? */
      this.proof_depth; /* How long is the longest
                        derivation chain from this
                        clause to an axiom? */
      this.proof_size;  /* How many (generating)
                        inferences were necessary to
                        create this clause? */
      this.children = new PTree_p();    /* Which can be removed if this clause changes significantly */
      this.parent1 = {};     /* Parents need to be notified */
      this.parent2 = {};     /* if their children are removed! */
      this.set = {};         /* Is the clause in a set? */
      this.pred = {};        /* For clause sets = doubly  */
      this.succ = {};        /* linked lists */
   }
   return obj
}
var ClauseCell = typedef_struct_clause_cell()
var Clause_p = typedef_struct_clause_cell()

// __import(cte_termtypes.h)
function typedef_long_DerefType()
{
   function obj(v)
   {
      this.value = v || 0
   }
   return obj
}
var DerefType_p = typedef_long_DerefType()

var DEREF_ALWAYS = -1
var DEREF_NEVER = 0
var DEREF_ONCE =  1

// typedef enum  /* See CLAUSES/ccl_rewrite.c for more */
function rewriteLevel()
{
   this.NoRewrite = 1 << 0     /* Just for completness */
   this.RuleRewrite = 1 << 1  /* Rewrite with rules only */
   this.FullRewrite = 1 << 2    /* Rewrite with rules and equations */
}
var RewriteLevel = new rewriteLevel()

function typedef_enum_termproperties()
{
   function obj()
   {
      this.TPIgnoreProps      =      0 /* For masking properties out */
      this.TPRestricted       =      1 /* Rewriting is restricted on this term */
      this.TPTopPos           =      2 /* This cell is a entry point */
      this.TPIsGround         =      4 /* Shared term is ground */
      this.TPPredPos          =      8 /* This is an original predicate position morphed into a term */
      this.TPIsRewritable     =     16 /* Term is known to be rewritable with
                                           respect to a current rule or rule
                                           set. Used for removing
                                           backward-rewritable clauses. Absence of
                                           this flag does not mean that the term
                                           is in any kind of normal form! POWNRS */
      this.TPIsRRewritable    =     32 /* Term is rewritable even if
                                           rewriting is restricted to proper
                                           instances at the top level.*/
      this.TPIsSOSRewritten   =     64 /* Term has been rewritten with a SoS clause (at top level) */
      this.TPSpecialFlag      =    128 /* For internal use with normalizing variables*/
      this.TPOpFlag           =    256 /* For internal use */
      this.TPCheckFlag        =    512 /* For internal use */
      this.TPOuthis.TPutFlag  =   1024 /* Has this term already been printed (and thus defined)? */
      this.TPIsSpecialVar     =   2048 /* Is this a meta-variable generated by term top operations and the like? */
      this.TPIsRewritten      =   4096 /* Term has been rewritten (for the new rewriting scheme) */ 
      this.TPIsRRewritten     =   8192 /* Term has been rewritten at a subterm position or with a real instance (for the new rewriting scheme) */ 
      this.TPIsShared         =  16384 /* Term is in a term bank */
      this.TPGarbageFlag      =  32768 /* For the term bank garbage collection */
      this.TPIsFreeVar        =  65536 /* For Skolemization */
      this.TPPotentialParamod = 131072 /* This position needs to be tried for paramodulation */
      this.TPPosPolarity      = 1<<18  /* In the term encoding of a formula, this occurs with positive polarity. */
      this.TPNegPolarity      = 1<<19  /* In the term encoding of a formula, this occurs with negative polarity. */
  }
  return obj
}
var TermProperties = termproperties()

function typedef_struct_rewritestate()
{
   function obj()
   {
         /* If term is not rewritten,
            it is in normal form with
            respect to the
            demodulators at this date */
      this.nf_date = new SysDate(RewriteLevel.FullRewrite); 
         /* ...otherwise, it has been rewritten to this term */
      this.rw_desc = {
         replace: new termcell(),
         //demod_id:0 /* 0 means subterm! */
         demod: clause_cell() /* NULL means subterm! */
      }
   }
   return obj
}
var RewriteState = typedef_struct_rewritestate()

function termcell()
{
   function obj()
   {
      this.properties = new TermProperties();   /* Like basic, lhs, top */
      this.f_code = new FunCode();              /* Top symbol of term */
      this.arity;                               /* Redundant, but saves handing
                                                   around the signature all the
                                                   time */
      this.args = [];                           /* Pointer to array of arguments */
      this.binding = {};                        /* For variable bindings,
                                                   potentially for temporary
                                                   rewrites - it might be possible
                                                   to combine the previous two in a
                                                   union. */
      this.entry_no;                            /* Counter for terms in a given
                                                   termbank - needed for
                                                   administration and external
                                                   representation */
      this.weight;                              /* Weight of the term, if term is
                                                   in term bank */
      this.rw_data = new RewriteState();        /* See above */
      this.lson = {};                           /* For storing shared term nodes in 
      this.rson = {};                              a splay tree - see cte_termcellstore.[ch] */
  }
  return obj
}
var TermCell = termcell()
var Term_p = termcell()
var TermRef = termcell()

// __import(cte_termbanks.h)
function tbcell()
{
   function obj()
   {
      this.in_count;       /* How many terms have been inserted? */
         /* Associate _external_ abbreviations (=
           entry_no's with term nodes, necessary
           for parsing of term bank terms. For
           critical cases (full protocolls) this
               is bound to be densly poulated -> we
           use an array. Please note that term
           replacing does not invalidate entries
           in ext_index
           (it would be pretty expensive in
           terms of time and memory), so higher
           layers have to take care of this if
           they want to both access terms via
           references and do replacing! */
      this.ext_index = new PDArray_p();
         /* For the mark-and sweep garbage
           collection. This is flipped at
           each sweep, and all new term cell
           get the new value, so that marking
           can be done by flipping in the
           term cell. */
      this.garbage_state = new TermProperties(); 
      this.sig = new Sig_p();               /* Store sig info */
      this.vars = new VarBank_p();          /* Information about (shared) variables */
      this.true_term = new Term_p ();       /* Pointer to the special term with the $true constant. */
      this.false_term = new Term_p ();      /* Pointer to the special term with the $false constant. */
      this.min_term = new Term_p ();        /* A small (ideally the minimal possible) term, to be used for RHS instantiation. */
      this.rewrite_steps;  /* How many calls to TBTermReplace? */
      this.term_store = new TermCellStoreCell (); /* Here are the terms */
         /* Higher level code can register
          * garbage collection information
          * here. This is only a convenience
          * link, memory needs to be managed
          * elsewhere. */
      this.gc = new gc_admin_cell()
   }
   return obj
}
var TBCell = tbcell()
var TB_p = tbcell()

// __import(ccl_garbage_coll.h)
function typedef_struct_gc_admin_cell()
{
   function obj()
   {
      this.bank = new TB_p();
      this.clause_sets = new PTree_p();
      this.formula_sets = new PTree_p();
   }
   return obj
}
var GCAdminCell = typedef_struct_gc_admin_cell()
var GCAdmin_p = typedef_struct_gc_admin_cell()

// __import(ccl_formulasets.h)
function typedef_struct_formula_set_cell()
{
   function obj()
   {
      this.anchor = new WFormula_p();
      this.members;
   }
   return obj
}
var FormulaSetCell = typedef_struct_formula_set_cell()
var FormulaSet_p = typedef_struct_formula_set_cell()

// __import(ccl_tformulae.h)
var TFormula_p = termcell() // typedef Term_p TFormula_p

// __import(ccl_formula_wrapper.h)
function typedef_enum_WFormulaProperties()
{
   function obj()
   {
      this.WPIgnoreProps   = 0,        /* For masking properties out */
      this.WPInitial       = 1,        /* Input formula */
      this.WPInputFormula       = ClauseProperties.CPInputClause, /* _Really_ initial in TSTP sense */
      this.WPType1              = ClauseProperties.CPType1, /* 128 */
      this.WPType2              = ClauseProperties.CPType2, 
      this.WPType3              = ClauseProperties.CPType3,
      this.WPTypeMask           = ClauseProperties.CPTypeMask,
      this.WPTypeUnknown        = 0,        /* Also used as wildcard */
      this.WPTypeAxiom          = ClauseProperties.CPTypeAxiom,      /* Formula is Axiom */
      this.WPTypeHypothesis     = ClauseProperties.CPTypeHypothesis, /* Formula is Hypothesis */
      this.WPTypeConjecture     = ClauseProperties.CPTypeConjecture, /* Formula is Conjecture */
      this.WPTypeLemma          = ClauseProperties.CPTypeLemma,      /* Formula is Lemma */
      this.WPTypeNegConjecture  = ClauseProperties.CPTypeNegConjecture, /* Formula is NegConjecture */
      this.WPTypeQuestion       = ClauseProperties.CPTypeQuestion,
      this.WPIsRelevant         = ClauseProperties.CPIsRelevant
   }
   return obj
}
var WFormulaProperties = typedef_enum_WFormulaProperties()

function typedef_struct_wformula_cell()
{ 
   function obj()
   {
      this.properties = new WFormulaProperties;
      this.ident;
      this.terms = new TB_p();
      this.info = new ClauseInfo_p();
      this.derivation = new PStack_p();
      this.tformula = new TFormula_p();
      this.set = new FormulaSetCell();      /* Is the formula in a set? */
      this.pred = {} // struct wformula_cell*;        /* For fomula sets = doubly  */
      this.succ = {} // struct wformula_cell*;        /* linked lists */
   }
   return obj
}
var WFormulaCell = typedef_struct_wformula_cell()
var WFormula_p = typedef_struct_wformula_cell()

// __import(clb_intmap.h)
function typedef_enum_IntMapType()
{
    function obj()
    {
        this.IMEmpty = 1 << 0
        this.IMSingle = 1 << 1
        this.IMArray = 1 << 3
        this.IMTree = 1 << 4
    }
    return obj
}
var IntMapType = typedef_enum_IntMapType()

var MAX_TREE_DENSITY = 8
var MIN_TREE_DENSITY = 4
var IM_ARRAY_SIZE = MAX_TREE_DENSITY

/* This is the main thing - a datatype that keeps key/value pairs and
 * allows inserting, updating, deleting, and ordered iteration. I
 * expect additons to be frequent and deletions to be rare. Element
 * access and iteration are the most frequent operations. We want this
 * time- and space efficient for many different key distributions. */

function typedef_struct_intmap_cell()
{
    function obj()
    {
        this.type = new IntMapType()
        this.entry_no
        this.min_key
        this.max_key
        this.values = {}
    }
    return obj
}
var IntMapCell = typedef_struct_intmap_cell()
var IntMap_p = typedef_struct_intmap_cell()

// __import(cte_idx_fp.h)
//typedef FunCode *IndexFP_p;
//typedef IndexFP_p (*FPIndexFunction)(Term_p t);
function FPIndexFunction()
{
   this.value = arguments[0] || {}
}

// __import(cte_fp_index.h)
/* This datatype is used for building fingerprint indexes for terms. A
 * fingerprint index is a trie over fingerprints. Fingerprints contain
 * the actual f_codes of certain sampled positions in a term, or the
 * values BELOW_VAR, ANY_VAR and NOT_IN_TERM to describe positions not
 * in the term and not in any possible instance of the term,
 * respectively. Function symbol
 * alternatives are handled in the obvious way. The values BELOW_VAR,
 * ANY_VAR, NOT_IN_TERM are now encoded  in f_alternatives[0,-1,-2]
 * according to their value. */

function typedef_struct_fp_index_cell()
{
    function obj()
    {
        this.f_alternatives = new IntMap_p()
        this.count
        this.payload = new PObjTree_p()
    }
    return obj
}
var FPTreeCell = typedef_struct_fp_index_cell()
var FPTree_p = typedef_struct_fp_index_cell()

//typedef void (*FPTreeFreeFun)(void*);
function FPTreeFreeFun()
{
   this.value = arguments[0] || {}
}

/* Wrapper for the index */

function typedef_struct_subterm_index_cell()
{
    function obj()
    {
        this.index = new FPTree_p()
        this.fp_fun = new FPIndexFunction()
        this.sig = new Sig_p()
        this.payload_free = new FPTreeFreeFun()
    }
    return obj
}
var FPIndexCell = typedef_struct_subterm_index_cell()
var FPIndex_p = typedef_struct_subterm_index_cell()

// __import(ccl_subterm_index.h)
var SubtermIndex_p = typedef_struct_subterm_index_cell() // typedef FPIndex_p SubtermIndex_p;

// __import(cte_idx_fp.h)
var MAX_PM_INDEX_NAME_LEN = 20

// __import(ccl_overlap_index.h)
var OverlapIndex_p = typedef_struct_subterm_index_cell() // new FPIndex_p()

// __import(ccl_global_indices.h)
function typedef_struct_global_indices_cell()
{
   function obj()
   {
      this.rw_bw_index_type = new Array(MAX_PM_INDEX_NAME_LEN)
      this.pm_from_index_type = new Array(MAX_PM_INDEX_NAME_LEN)
      this.pm_into_index_type = new Array(MAX_PM_INDEX_NAME_LEN)
      this.pm_negp_index_type = new Array(MAX_PM_INDEX_NAME_LEN)
      this.sig = new Sig_p();
      this.bw_rw_index = new SubtermIndex_p()
      this.pm_from_index = new OverlapIndex_p()
      this.pm_into_index = new OverlapIndex_p()
      this.pm_negp_index = new OverlapIndex_p()
   }
   return obj
}
var GlobalIndices = typedef_struct_global_indices_cell()
var GlobalIndices_p = typedef_struct_global_indices_cell()

// __import(ccl_freqvectors.h)
var FV_CLAUSE_FEATURES = 2

function typedef_enum_FVIndexType()
{
    function obj()
    {
        this.FVINoFeatures = 1 << 0
        this.FVIACFeatures = 1 << 1
        this.FVISSFeatures = 1 << 2
        this.FVIAllFeatures = 1 << 3
        this.FVIBillFeatures = 1 << 4
        this.FVIBillPlusFeatures = 1 << 5
        this.FVIACFold = 1 << 6
        this.FVIACStagger = 1 << 7
        this.FVICollectFeatures = 1 << 8
    }
    return obj
}
var FVIndexType = typedef_enum_FVIndexType()

/* Describe how to assembe a feature vector out of a full signature
 * feature vector. */

function typedef_struct_fv_collect_cell()
{
    function obj()
    {
        this.features = new FVIndexType()
        this.use_litcount
        this.assembly_vector
        this.ass_vec_len
        this.res_vec_len
        this.pos_count_base
        this.pos_count_offset
        this.pos_count_mod
        this.neg_count_base
        this.neg_count_offset
        this.neg_count_mod
        this.pos_depth_base
        this.pos_depth_offset
        this.pos_depth_mod
        this.neg_depth_base
        this.neg_depth_offset
        this.neg_depth_mod
        this.max_symbols
    }
    return obj
}
var FVCollectCell = typedef_struct_fv_collect_cell()
var FVCollect_p = typedef_struct_fv_collect_cell()

// __import(clb_numtrees.h)
/* General purpose data structure for indexing objects by a numerical
   key. Integer values are supported directly, for all other objects
   pointers can be used (and need to be casted carefully by the
   wrapper functions). Objects pointed to by the value fields are not
   part of the data stucture and will not be touched by deallocating
   trees or tree nodes. */ 

function typedef_struct_numtreecell()
{
    function obj()
    {
        this.key
        this.val1 = new IntOrP()
        this.val2 = new IntOrP()
        this.lson = {}
        this.rson = {}
    }
    return obj
}
var NumTreeCell = typedef_struct_numtreecell()
var NumTree_p = typedef_struct_numtreecell()

// __import(ccl_def_handling.h)
function typedef_struct_def_store_cell()
{
    function obj()
    {
        this.terms = new TB_p()
        this.def_clauses = new ClauseSet_p()
        this.def_assocs = new NumTree_p()
        this.def_archive = new FormulaSet_p()
    }
    return obj
}
var DefStoreCell = typedef_struct_def_store_cell()
var DefStore_p = typedef_struct_def_store_cell()

/* Clause sets are doubly linked lists of clauses with indices for the
   various potential evaluations. */

function typedef_struct_clausesetcell()
{
    function obj()
    {
        this.members
        this.literals
        this.anchor = new Clause_p()
        this.date = new SysDate()
        this.demod_index = new PDTree_p()
        this.fvindex = new FVIAnchor_p()
        this.eval_indices = new PDArray_p()
        this.eval_no
    }
    return obj
}
var ClauseSetCell = typedef_struct_clausesetcell()
var ClauseSet_p = typedef_struct_clausesetcell()

// __import(ccl_proofstate.h)
function proofstatecell ()
{
    function obj()
    {
       this.signature = new Sig_p();
       this.freshvars = new VarBank_p();
       this.original_terms = new TB_p();
       this.terms = new TB_p();
       this.tmp_terms = new TB_p();
       this.gc_original_terms = new GCAdmin_p();
       this.gc_terms = new GCAdmin_p(); 
       this.f_ax_archive = new FormulaSet_p();
       this.f_axioms = new FormulaSet_p();
       this.f_archive = new FormulaSet_p()
       this.axioms = new ClauseSet_p();
       this.ax_archive = new ClauseSet_p();
       this.processed_pos_rules = new ClauseSet_p();
       this.processed_pos_eqns = new ClauseSet_p();
       this.processed_neg_units = new ClauseSet_p();
       this.processed_non_units = new ClauseSet_p();
       this.unprocessed = new ClauseSet_p();
       this.tmp_store = new ClauseSet_p();
       this.archive = new ClauseSet_p();
       this.demods = [  
            new ClauseSet_p(),
            new ClauseSet_p(),
            new ClauseSet_p()
       ];   /* Synonyms for processed_pos_rules and processed_pos_eqns */
       this.watchlist = new ClauseSet_p();
       this.extract_roots = new PStack_p();
       this.gindices = new GlobalIndices();
       this.wlindices = new GlobalIndices();
       this.fvi_initialized;    /* Are the feature vector indices set up? */
       this.def_store_cspec = new FVCollect_p();
       this.fvi_cspec = new FVCollect_p();
       this.definition_store = new DefStore_p();
       this.state_is_complete;
       this.original_symbols;
       this.status_reported;
       this.answer_count;
       this.processed_count;
       this.proc_trivial_count;
       this.proc_forward_subsumed_count;
       this.proc_non_trivial_count;
       this.other_redundant_count;  /* Intermediate filtering */
       this.non_redundant_deleted;
       this.backward_subsumed_count;
       this.backward_rewritten_count;
       this.backward_rewritten_lit_count;
       this.generated_count;
       this.generated_lit_count;
       this.non_trivial_generated_count;
       this.context_sr_count;
       this.paramod_count;
       this.factor_count;
       this.resolv_count;
   } // obj()
   return obj
} // proofstatecell ()
var ProofStateCell = proofstatecell()
var ProofState_p = proofstatecell()

// __import(ccl_proofstate.c)
function ProofStateCellAlloc()
{
   return arguments[0] || new ProofStateCell()
}

function ProofStateCellFree(junk)
{
   junk = undefined
}

// __import(clb_properties.h)
function SetProp(obj, prop)
{
   obj.properties = obj.properties | prop
   return obj
}

function DelProp(obj, prop)
{
   obj.properties = obj.properties & ~prop
   return obj
}

function FlipProp(obj, prop)
{
   obj.properties = obj.properties ^ prop
   return obj
}

function AssignProp(obj, sel, prop)
{
   obj = DelProp(obj,sel)
   obj = SetProp(obj,sel&prop)
   return obj
}

/* Are _all_ properties in prop set in obj? */
function QueryProp(obj, prop)
{
   return ((obj.properties & prop) == prop)
}

/* Are any properties in prop set in obj? */
function IsAnyPropSet(obj, prop)
{
   return (obj.properties & prop)
}

/* Return the properties of object...yes, this is the same code as
   above, but implements a different concept */
function GiveProps(obj,prop)
{
   return (obj.properties & prop)
}

/* Are two property sets equivalent? */

function PropsAreEquiv(obj1, obj2, props)
{
   return ((obj1.properties & props)==(obj2.properties & props))
}

// __import(cte_signature.h)
var SIG_TRUE_CODE = 1
var SIG_FALSE_CODE = 2
var SIG_NIL_CODE = 3
var SIG_CONS_CODE = 4

var FuncSetProp = SetProp
var FuncDelProp = DelProp

/* Are _all_ properties in prop set for symb? */
var FuncQueryProp = QueryProp

/* Are any properties in prop set in term? */
var FuncIsAnyPropSet = IsAnyPropSet

/* With a more convenient external interface: */

function SigSetFuncProp(sig, symb, prop)
{
   return FuncSetProp(sig.f_info[symb], prop)
}

function SigDelFuncProp(sig, symb, prop)
{
   return FuncDelProp(sig.f_info[symb], prop)
}
        
function SigQueryFuncProp(sig, symb, prop)
{
   return FuncQueryProp(sig.f_info[symb], prop)
}

function SigIsAnyFuncPropSet(sig, symb, prop)
{
   return FuncIsAnyPropSet(sig.f_info[symb], prop)
}

function SigCellAlloc()
{
   return arguments[0] || new SigCell()
}

function SigCellFree(junk)
{
   junk = undefined
}

// __import(clb_newmem.c)
function MemFlushFreeList()
{
   console.log("MemFlushFreeList: FLUSH called; Note: This is a NOP in new memory-handlers")
}

// __import(ahs)
function realloc(sz,typeOfsz,SIZE)
{
   try{
      if(SIZE){
         if(sz && sz.length && sz.length < SIZE){
            for(var i=sz.length; i<SIZE; i++){
               sz.push(new typeOfsze())
            }
         } else {
            console.log( "realloc: Memory allocation error - *** Warning *** incorrect specified length or Source is not an Array" )
         }
      }
   } catch (e) {
      console.log(e)
   }
   return sz
}

// __import(ahs)
function malloc(typeOfsze,SIZE)
{
   try{
      var obj = new typeOfsze()
      if(SIZE){
         var c= new Array(SIZE)
         c = c.map(function(v){
            return obj
         })
         if(c){
            obj = c
         }
      }
      return obj
   } catch (e) {
      console.log(e)
   }
}

/*-----------------------------------------------------------------------
//
// Function: SecureMalloc()
//
//  Returns a pointer to an unused memory block sized size. If
//  possible, a fresh block is allocated, if not, the
//  reorganization of free_mem_list is triggered, if still no memory
//  is available, an error will be produced.
//
// Global Variables: free_mem_list
//
// Side Effects    : Memory operations, possibly error
//
/----------------------------------------------------------------------*/

function SecureMalloc( typeOf,size )
{
   var handle = new sizeof()
   if(CLB_MEMORY_DEBUG){
      secure_malloc_count++
      secure_malloc_mem += size
   }
   handle = realloc(handle,typeOf,size)
   if(!handle)
   {    
      MemIsLow = true
      MemFlushFreeList() 
      
      handle = malloc(typeOf,size)
      
      if(!handle)
      {   
         if(PRINT_SOMEERRORS_STDOUT){
              console.log( "SecureMalloc: # Failure: Resource limit exceeded: memory")
         }
         throw "Out of Memory"
      }
   }
   return handle
}

function SizeMalloc(typeOf)
{
   return malloc(typeOf)
}

function SizeFree(junk)
{
   junk = undefined
}

// __import(clb_pstacks.h)
var PSTACK_DEFAULT_SIZE = 128

function PStackCellAlloc(handle)
{
   return handle || SizeMalloc(PStackCell)
}

/*-----------------------------------------------------------------------
//
// Function: PStackAlloc()
//
//   Allocate an empty stack.
//
// Global Variables: -
//
// Side Effects    : Memory oprations
//
/----------------------------------------------------------------------*/

function PStackAlloc()
{
   var handle = new PStack_p()
   
   handle = PStackCellAlloc(handle)
   handle.size = PSTACK_DEFAULT_SIZE
   handle.current = 0
   handle.stack = SizeMalloc(IntOrP,handle.size)
   
   return handle
}

// __import(clb_floattrees.c)
/*-----------------------------------------------------------------------
//
// Function: splay_tree() 
//
//   Perform the splay operation on tree at node with key.
//
// Global Variables: -
//
// Side Effects    : Changes tree
//
/----------------------------------------------------------------------*/

function splay_tree( tree,key ) 
{
   var left = new FloatTree_p()
   var right = new FloatTree_p()
   var tmp = new FloatTree_p()
   var N = new FloatTreeCell()
   if (!tree) 
   {
      return tree
   }
   
   N.lson = null
   N.rson = null
   left = N
   right = N
   
   while(1) 
   {
      var cmpres = key-tree.key
      if (cmpres < 0) 
      {
         if(!tree.lson)
         {
            break
         }
         if((key-tree.lson.key) < 0)
         {
            tmp = tree.lson
            tree.lson = tmp.rson
            tmp.rson = tree
            tree = tmp
            if (!tree.lson)
            {
               break
            }
         }
         right.lson = tree
         right = tree
         tree = tree.lson
      } 
      else if(cmpres > 0)
      {
         if (!tree.rson)
         {
            break
         }
         if((key-tree.rson.key) > 0) 
         {
            tmp = tree.rson
            tree.rson = tmp.lson
            tmp.lson = tree
            tree = tmp
            if (!tree.rson) 
            {
               break
            }
         }
         left.rson = tree
         left = tree
         tree = tree.rson
      }
      else 
      {
         break
      }
   }
   left.rson = tree.lson
   right.lson = tree.rson
   tree.lson = N.rson
   tree.rson = N.lson
   
   return tree
}

// __import(clb_stringtrees.c)
/*-----------------------------------------------------------------------
//
// Function: StrTreeFind()
//
//   Find the entry with key key in the tree and return it. Return
//   NULL if no such key exists.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function StrTreeFind( root,key )
{
   var result = null
   if(root)
   {
      root = splay_tree(root, key)
      if(root.key===key)
      {
         result = root
      }
   }
   return result
}

// __import(cte_signature.c)
/*-----------------------------------------------------------------------
//
// Function: SigFindFCode()
//
//   Return the index of the entry name in sig, or 0 if name is not in
//   sig.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function SigFindFCode( sig,name )
{
   var result = 0
   var entry = StrTreeFind(sig.f_index, name)
   if(entry)
   {
      result = entry.val1.i_val
   }
   return result
}



/*-----------------------------------------------------------------------
//
// Function: SigSetSpecial()
//
//   Set the value of the special field for a function symbol.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function SigSetSpecial( sig,f_code,value )
{
   var result
   console.log('SigSetSpecial: f_code > 0',f_code > 0,', f_code <= sig.f_count',f_code <= sig.f_count)
   if(value)
   {
      result = SigSetFuncProp(sig,f_code,FPSpecial)
   }
   else
   {
      result = SigDelFuncProp(sig,f_code,FPSpecial)
   }
   return result
}

// __import(clb_memory.c)
/* This global variable is set whenever malloc() failed and triggered
   a free memory reorganization. User programs may examine this
   variable to take certain measures (and may reset it if they think
   that they freed significant amounts of memory). However, this
   is somewhat discouraged - do you really want your program to depend
   in pretty complex ways on uncontrolable features like the amount of
   free memory available to your process? _I_ only used to use it for
   some measurements ;-)  StS */
/* Administrate deallocated memory blocks */

function typedef_struct_memcell()
{
   function obj(v)
   {
      this.next
      if(v){
         this.next = new Array(v) // = typedef_struct_memcell()
         this.next = this.next.map(function(r){ return 0 })
      }
      if(NDEBUG)
      {
         this.test
      }
   }
   return obj
}
var MemCell = typedef_struct_memcell()
var Mem_p = typedef_struct_memcell()
   
var MEM_ARR_SIZE = 8192
var MEM_FREE_PATTERN = 0xFAFBFAFA
var MEM_RSET_PATTERN = 0x00000000

var MemIsLow = false;
var free_mem_list = new Mem_p(MEM_ARR_SIZE)

if(CLB_MEMORY_DEBUG)
{
   size_malloc_mem = 0;
   size_malloc_count = 0;
   size_free_mem = 0;
   size_free_count = 0;
   clb_free_count = 0;
   secure_malloc_count = 0;
   secure_malloc_mem = 0;
   secure_realloc_count = 0;
   secure_realloc_m_count = 0;
   secure_realloc_f_count = 0;
}


/*-------------------------------------------------------------------------
//
// Function: SecureRealloc()
//
//   Imitates realloc, but reorganizes free_mem_list to get new memory
//   if the block has to be moved and no memory is available. Will
//   terminate with OUT_OF_MEMORY if no memory is found. 
//
// Global Variables: -
//
// Side Effect: Via SecureMalloc()
//
//-----------------------------------------------------------------------*/

function SecureRealloc( ptr,typeOfptr,size )
{
   var handle
   
   if(CLB_MEMORY_DEBUG)
   {
      secure_realloc_count++
      if(ptr && !size)
      {
         secure_realloc_f_count++
      }
      else if(!ptr && size)
      {
         secure_realloc_m_count++
      }
   }
   
   handle = ptr?realloc(ptr,typeOfptr,size):malloc(typeOfptr,size)
   if(!handle && size!=0)
   {
      MemIsLow = true
      MemFlushFreeList()
      handle = ptr?realloc(null,typeOfptr,size):malloc(typeOfptr,size)
      if(!handle)
      {   
         if(PRINT_SOMEERRORS_STDOUT)
         {
            SetMemoryLimit(RLIM_INFINITY)
            srcTranslated.value += "# Failure: Resource limit exceeded (memory)\n"
         }
         throw "Out of Memory"
      }
   }
   if(CLB_MEMORY_DEBUG2)
   {
      if(ptr != handle)
      {
         if(ptr)
         {
            console.log("SecureRealloc: Block ",ptr," F:")
         }
         console.log("SecureRealloc: Block ",handle," R: ",size)
      }
   }
   return handle
}


/*-----------------------------------------------------------------------
//
// Function: SigSetAllSpecial()
//
//   Set the special value of all symbols in sig.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function SigSetAllSpecial( sig,value )
{
   for(var i=1; i<=sig.f_count; i++)
   {
      SigSetSpecial(sig, i, value)
   }
}

/*-----------------------------------------------------------------------
//
// Function: SecureStrdup()
//
//   Implements the functionality of strdup, but uses SecureMalloc()
/    for the memory handling. 
//
// Global Variables: -
//
// Side Effects    : By SecureMalloc()
//
/----------------------------------------------------------------------*/

function SecureStrdup( source )
{
   return source
}

// __import(clb_stringtrees.c)
function StrTreeCellAlloc()
{
   return malloc(StrTreeCell)
}

/*-----------------------------------------------------------------------
//
// Function: StrTreeCellAllocEmpty()
//
//   Allocate a empty, initialized StrTreeCell. Pointers to children
//   are NULL, int values are 0 (and pointer values in ANSI-World
//   undefined, in practice NULL on 32 bit machines)(This comment is
//   superfluous!). 
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function StrTreeCellAllocEmpty()
{
   var handle = StrTree_p()
   handle.val1.i_val = handle.val2.i_val = 0
   handle.lson = handle.rson = NULL
   return handle
}

/*-----------------------------------------------------------------------
//
// Function: StrTreeInsert()
//
//   If an entry with key *newnode->key exists in the tree return a
//   pointer to it. Otherwise insert *newnode in the tree and return
//   NULL. 
//
// Global Variables: -
//
// Side Effects    : Changes the tree
//
/----------------------------------------------------------------------*/

function StrTreeInsert( root,newnode )
{
   var cmpres
   if (!root) 
   {
      newnode.lson = newnode.rson = NULL
      return { root:newnode,newnode:newnode,value:null }
   }
   root = splay_tree(root, newnode.key)
   cmpres = (newnode.key == root.key)
   
   if (cmpres)
   {
      newnode.lson = root.lson
      newnode.rson = root
      root.lson = NULL
      return { root:newnode,newnode:newnode,value:null }
   } 
   else
   {
      newnode.rson = root.rson
      newnode.lson = root
      root.rson = NULL
      return { root:newnode,newnode:newnode,value:null }
   }
   return { root:root,newnode:newnode,value:root }
}

/*-----------------------------------------------------------------------
//
// Function: SigInsertId()
//
//   Insert the symbol name with arity into the signature. Return the
//   f_code assigned to the name or 0 if the same name has already
//   been used with a different arity.
//
// Global Variables: -
//
// Side Effects    : Potential memory operations.
//
/----------------------------------------------------------------------*/

function SigInsertId( sig,name,arity,special_id )
{
   var pos
   var en = new FunctionProperties()
   var N = new StrTree_p()
   var obj // = new StrTree_p()
   pos = SigFindFCode(sig, name)
   if(pos) 
   {
      if(sig.f_info[pos].arity != arity)
      {
         console.log("SigInsertId: Problem: ",name," ",arity," != ",sig.f_info[pos].arity)
         return 0 
      }
      if(special_id)
      {
         sig.f_info[pos] = SigSetSpecial(sig, pos, true)
      }
      return pos 
   }
   
   if(sig.f_count == sig.size-1)
   {
      
      sig.size *= DEFAULT_SIGNATURE_GROW
      sig.f_info = SecureRealloc(sig.f_info,
                   FuncCell,sig.size)
   }
   
   sig.f_count++
   sig.f_info[sig.f_count].name
      = SecureStrdup(name)
   sig.f_info[sig.f_count].arity = arity
   sig.f_info[sig.f_count].properties = en.FPIgnoreProps
   N = StrTreeCellAllocEmpty()
   N.key = sig.f_info[sig.f_count].name
   N.val1.i_val = sig.f_count
   obj = StrTreeInsert(sig.f_index, N)
   sig.f_index = obj.root
   N = obj.newnode
   console.log('SigInsertId: obj == NULL :',obj.value == NULL)
   SigSetSpecial(sig,sig.f_count,special_id)
   sig.alpha_ranks_valid = false
   return sig.f_count
}

/*-----------------------------------------------------------------------
//
// Function: SigAlloc()
//
// Allocate a initialized signature cell.
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function SigAlloc()
{
   var en = new FunctionProperties()
   var handle = new Sig_p()
   handle = SigCellAlloc( handle )
   handle.alpha_ranks_valid = false
   handle.size           = DEFAULT_SIGNATURE_SIZE
   handle.f_count        = 0
   handle.f_info         =
      SecureMalloc(FuncCell,DEFAULT_SIGNATURE_SIZE) 
   handle.f_index = NULL
   handle.ac_axioms = PStackAlloc()
   SigInsertId(handle, "$true", 0, true)
   console.log('SigAlloc: handle=SIG_TRUE_CODE:',SigFindFCode(handle, "$true")==SIG_TRUE_CODE)
   SigSetFuncProp(handle, SIG_TRUE_CODE, en.FPPredSymbol|en.FPInterpreted)
   SigInsertId(handle, "$false", 0, true)
   console.log('SigAlloc: handle=SIG_FALSE_CODE',SigFindFCode(handle, "$false")==SIG_FALSE_CODE)
   SigSetFuncProp(handle, SIG_FALSE_CODE, en.FPPredSymbol|en.FPInterpreted)
   
   if(SigSupportLists)
   {
      SigInsertId(handle, "$nil", 0, true)
      console.log('SigAlloc: handle=SIG_NIL_CODE: ',SigFindFCode(handle, "$nil")==SIG_NIL_CODE)
      SigInsertId(handle, "$cons", 2, true)
      console.log('SigAlloc: handle=SIG_CONS_CODE: ',SigFindFCode(handle, "$cons")==SIG_CONS_CODE)
   }
   
   handle.internal_symbols = handle.f_count
   
   handle.eqn_code      = 0
   handle.neqn_code     = 0
   handle.cnil_code     = 0
   handle.orn_codes     = NULL
   handle.or_code           = 0
   handle.not_code          = 0
   handle.qex_code          = 0
   handle.qall_code         = 0
   handle.and_code          = 0
   handle.or_code           = 0
   handle.impl_code         = 0
   handle.equiv_code        = 0
   handle.nand_code         = 0
   handle.nor_code          = 0
   handle.bimpl_code        = 0
   handle.xor_code          = 0
   handle.answer_code       = 0
   handle.skolem_count      = 0
   handle.newpred_count     = 0
   
   handle.distinct_props = en.FPDistinctProp
   return handle
}

// __import(cte_termbanks.c)
function TBCellAlloc(){
   return SizeMalloc(TBCell)
}

function TBCellFree(junk){
   SizeFree(junk, sizeof(TBCell))
}

// __import(clb_pdarrays.c)
function PDArrayCellAlloc()
{
   return arguments[0] || SizeMalloc(PDArrayCell)
}

/*-----------------------------------------------------------------------
//
// Function: PDIntArrayAlloc()
//
//   Return an initialized dynamic array of size init_size where all
//   elements are interpreted as (long) integers and initialized to 0.
//
// Global Variables: -
//
// Side Effects    : Memory Operations
//
/----------------------------------------------------------------------*/

function PDIntArrayAlloc( init_size,grow )
{
   var handle = new PDArray_p ()
   handle = new PDArrayCellAlloc( handle )
   
   console.log('PDIntArrayAlloc: init_size > 0', init_size > 0, ', grow >= 0',grow >= 0)
   handle.integer = true
   handle.size  = init_size
   handle.grow  = grow
   handle.array = SizeMalloc(IntOrP,handle.size)
   for(var i=0; i<handle.size; i++)
   {
      handle.array[i].i_val = 0
   }
   return handle
}

function VarBankCellAlloc(handle)
{
   return handle || SizeMalloc(VarBankCell)
}

var DEFAULT_VARBANK_SIZE = 30
var GROW_EXPONENTIAL = 0

/*-----------------------------------------------------------------------
//
// Function:  VarBankAlloc()
//
//   Allocate an empty, initialized VarBank-Structure, return pointer
//   to it.
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function VarBankAlloc()
{
   var handle = new VarBank_p()
   handle = VarBankCellAlloc(handle)
   handle.v_count = 0
   handle.max_var = 0
   handle.ext_index = NULL
   handle.f_code_index = 
      PDIntArrayAlloc(DEFAULT_VARBANK_SIZE,GROW_EXPONENTIAL)
   return handle
}

var TERM_STORE_HASH_SIZE = 1 << 15 // (8192*4)

/*-----------------------------------------------------------------------
//
// Function: TermCellStoreInit()
//
//   Initialize a term cell storage.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function TermCellStoreInit( store )
{
   store.entries = 0
   store.arg_count = 0
   for(var i=0; i<TERM_STORE_HASH_SIZE; i++)
   {
      store.store[i] = NULL
   }
  return store
}

function TermCellAlloc(handle)
{
   return handle || SizeMalloc(TermCell)
}

var DEFAULT_VWEIGHT = 1  /* This has to be an integer > 0! */
var DEFAULT_FWEIGHT = 2  /* This has to be >= DEFAULT_VWEIGHT */

function SysDate()
{
   this.value = arguments[0] || 0
}

function typedef_enum_DateRelation()
{
    function obj()
    {
        this.DateEarlier=-1
        this.DateEqual=0
        this.DateLater=1
    }
    return obj
}
var DateRelation = typedef_enum_DateRelation()

function SysDateCreationTime()
{
   return new Date().getTime() // SysDate().DateEqual
}

/*-----------------------------------------------------------------------
//
// Function: TermDefaultCellAlloc()
//
//   Allocate a term cell with default values.
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function TermDefaultCellAlloc()
{
   var d = SysDateCreationTime()
   var en = new TermProperties()
   var handle = new Term_p()
   
   handle = TermCellAlloc(handle)
   handle.properties = en.TPIgnoreProps
   handle.arity = 0
   handle.binding = NULL
   handle.args = NULL
   handle.weight = DEFAULT_VWEIGHT
   handle.rw_data.nf_date[0] = d
   handle.rw_data.nf_date[1] = d
   
   return handle
}

var TERMS_INITIAL_ARGS = 10

function RewriteAdr(level)
{
   console.log('RewriteAdr: level ',level--)
   return level
}

function TermIsVar(t)
{
   return (t.f_code < 0)
}

function TermIsConst(t)
{
   return (!TermIsVar(t) && (t.arity==0))
}

function TermCellSetProp(term, prop)
{
   return SetProp(term, prop)
}

function TermCellDelProp(term, prop)
{
   return DelProp(term, prop)
}

function TermCellAssignProp(term, sel, prop)
{
   return AssignProp(term,sel,prop)
}

/* Are _all_ properties in prop set in term? */
function TermCellQueryProp(term, prop)
{
   return QueryProp(term, prop)
}

/* Are any properties in prop set in term? */
function TermCellIsAnyPropSet(term, prop)
{
   return IsAnyPropSet(term, prop)
}

function TermCellGiveProps(term, props)
{
   return GiveProps(term,props)
}

function TermCellFlipProp(term, props)
{
   return FlipProp(term,props)
}

function TermCellAlloc()
{
   return SizeMalloc(TermCell)
}

function TermCellFree(junk)
{
   SizeFree(junk, TermCell)
}

function TermArgArrayAlloc(arity)
{
   return SizeMalloc(arity,Term_p)
}

function TermArgArrayFree(junk, arity)
{
   SizeFree(junk,arity,Term_p)
}

function TermIsRewritten(term)
{
   var en = new TermProperties()
   return TermCellQueryProp(term, en.TPIsRewritten)
}

function TermIsRRewritten(term)
{
   var en = new TermProperties()
   return TermCellQueryProp(term, en.TPIsRRewritten)
}

function TermIsTopRewritten(term)
{
   return (TermIsRewritten(term)&&TermRWDemodField(term))
}

function TermIsShared(term)
{
   var en = new TermProperties()
   return TermCellQueryProp((term), en.TPIsShared)
}

function TermNFDate(term,i)
{
   return (TermIsRewritten(term) ? SysDateCreationTime():term.rw_data.nf_date[i])
}

/* Absolutely get the value of the replace and demod fields */
function TermRWReplaceField(term)
{
   return (term.rw_data.rw_desc.replace)
}

function TermRWDemodField(term)
{
   return (term.rw_data.rw_desc.demod)
}

var REWRITE_AT_SUBTERM = 0

/* Get the logical value of the replaced term / demodulator */
function TermRWReplace(term)
{
   return (TermIsRewritten(term) ? TermRWTargetField(term):NULL)
}

function TermRWDemod(term)
{
   return (TermIsRewritten(term) ? TermRWDemodField(term):NULL)
}

/*-----------------------------------------------------------------------
//
// Function: TBAlloc()
//
//   Allocate an empty, initialized termbank.
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function TBAlloc( sig )
{
   var en = new TermProperties()
   var handle = new TB_p()
   var term = new Term_p()
   handle = new TBCellAlloc(handle)
   handle.in_count = 0
   handle.rewrite_steps = 0
   handle.ext_index = PDIntArrayAlloc(1,1e5)
   handle.garbage_state = en.TPIgnoreProps
   handle.sig = sig
   handle.vars = VarBankAlloc()
   handle.term_store = TermCellStoreInit(handle.term_store)
   term = TermDefaultCellAlloc(term)
   term.f_code = SIG_TRUE_CODE
   term = TermCellSetProp(term, en.TPPredPos)
   handle.true_term = TBInsert(handle, term, DEREF_NEVER)
   TermFree(term)
   term = TermDefaultCellAlloc(term)
   term.f_code = SIG_FALSE_CODE
   term = TermCellSetProp(term, en.TPPredPos)
   handle.false_term = TBInsert(handle, term, DEREF_NEVER)
   TermFree(term)
   handle.min_term = 0
   return handle
}

// __import(ccl_formula_wrapper
function WFormulaCellAlloc()
{
   return SizeMalloc(WFormulaCell)
}

// __import(ccl_formulasets.c:)
/*-----------------------------------------------------------------------
//
// Function: FormulaSetAlloc()
//
//   Allocate and initialize a formula set.
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function FormulaSetAlloc()
{
   var set = FormulaSet_p()
   set.members = 0
   set.anchor  = new WFormulaCellAlloc()
   set.anchor.succ = set.anchor
   set.anchor.pred = set.anchor
   
   return set
}

function ClauseSetCellAlloc()
{
   return SizeMalloc(ClauseSetCell)
}

/*-----------------------------------------------------------------------
//
// Function: ClauseCellAlloc()
//
//   Allocate a clause cell. This is a thin wrapper only relevant when
//   perm-idents are enabled for debugging.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/
var clause_perm_ident_counter = 0

function ClauseCellAlloc()
{
    var handle = new Clause_p()
    handle = ClauseCellAllocRaw(handle);

   if(CLAUSE_PERM_IDENT)
   {
      handle.perm_ident = clause_perm_ident_counter++;
   }

   return handle;
}

function SysDateInc(sd)
{
   console.log('SysDateInc: sd=',++sd)
   return sd
}

/*-----------------------------------------------------------------------
//
// Function: PDArrayAlloc()
//
//   Return an initialized dynamic array of size init_size where all
//   elements are interpreted as pointers and initialized to NULL.
//
// Global Variables: -
//
// Side Effects    : Memory Operations
//
/----------------------------------------------------------------------*/

function PDArrayAlloc( init_size,grow )
{
   var handle = new PDArray_p()
   handle = PDArrayCellAlloc(handle)
   
   console.log('PDArrayAlloc: init_size > 0',init_size > 0,', grow >= 0',grow >= 0)
   handle.integer = false
   handle.size  = init_size
   handle.grow  = grow
   handle.array = SizeMalloc(IntOrP,handle.size)
   for(var i=0; i<handle.size; i++)
   {
      handle.array[i].p_val = NULL
   }
   return handle
}

/*-----------------------------------------------------------------------
//
// Function: ClauseSetAlloc()
//
//   Allocate an empty clause set that uses SysDate for (logical)
//   time-keeping.
//
// Global Variables: -
//
// Side Effects    : Memory management
//
/----------------------------------------------------------------------*/

function ClauseSetAlloc()
{
   var handle = new ClauseSet_p()
   handle = ClauseSetCellAlloc(handle)
   
   handle.members = 0
   handle.literals = 0
   handle.anchor = new ClauseCellAlloc()
   handle.anchor.literals = NULL
   handle.anchor.pred = handle.anchor.succ = handle.anchor
   handle.date = new SysDateCreationTime()
   handle.date = SysDateInc(handle.date)
   handle.demod_index = NULL
   handle.fvindex = NULL
   
   handle.eval_indices = new PDArrayAlloc(4,4)
   handle.eval_no = 0
   return handle
}

/*-----------------------------------------------------------------------
//
// Function: SigSetPredicate()
//
//   Set the value of the predicate field for a function symbol.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function SigSetPredicate( sig,f_code,value )
{
   var en = new FunctionProperties()
   console.log('SigSetPredicate: f_code > 0',f_code > 0,', f_code <= sig.f_count',f_code <= sig.f_count)
   if(value)
   {
      sig.f_info[f_code] = FuncSetProp(sig.f_info[f_code],en.FPPredSymbol)
   }
   else
   {
      sig.f_info[f_code] = FuncDelProp(sig.f_info[f_code],en.FPPredSymbol)
   }
   return sig
}

/*-----------------------------------------------------------------------
//
// Function: SigInitInternalCodes()
//
//   Put all the FOF operators as function symbols into sig. Sig
//   should be empty, so that sig->internal symbols can be properly
//   initialized.  Note that this will be used for plain term
//   signatures. It reuses some equivalent fields of signatures used
//   for patterns, but morphs the f_codes into internal symbols.
//
// Global Variables: -
//
// Side Effects    : Changes sig...
//
/----------------------------------------------------------------------*/

function SigInsertInternalCodes( sig )
{
   var en = new FunctionProperties()
   console.log('SigInsertInternalCodes: ',
      'SigSupportLists && sig.internal_symbols:',
      ((SigSupportLists && sig.internal_symbols) == SIG_CONS_CODE),
      ', !SigSupportLists && sig.internal_symbols:',
      ((!SigSupportLists && sig.internal_symbols) == SIG_FALSE_CODE)
    )
   
   sig.eqn_code    = SigInsertId(sig, "$eq",2, true)
   sig = SigSetPredicate(sig, sig.eqn_code, true)
   sig.neqn_code   = SigInsertId(sig, "$neq",2, true)
   sig = SigSetPredicate(sig, sig.neqn_code, true)
   sig.qex_code   = SigInsertId(sig, "$qex",2, true)
   sig.qall_code  = SigInsertId(sig, "$qall",2, true)
   sig.not_code   = SigInsertFOFOp(sig, "$not",   1)
   sig.and_code   = SigInsertFOFOp(sig, "$and",   2)
   sig.or_code    = SigInsertFOFOp(sig, "$or",    2)
   sig.impl_code  = SigInsertFOFOp(sig, "$impl",  2)
   sig.equiv_code = SigInsertFOFOp(sig, "$equiv", 2)
   sig.nand_code  = SigInsertFOFOp(sig, "$nand",  2)
   sig.nor_code   = SigInsertFOFOp(sig, "$nor",   2)
   sig.bimpl_code = SigInsertFOFOp(sig, "$bimpl", 2)
   sig.xor_code   = SigInsertFOFOp(sig, "$xor",   2)
   sig.xor_code   = SigInsertFOFOp(sig, "$xor",   2)
   sig.answer_code =  SigInsertId(sig, "$answer", 1, true)
   sig = SigSetPredicate(sig, sig.answer_code, true)
   sig = SigSetFuncProp(sig, sig.answer_code, en.FPInterpreted|en.FPPseudoPred)
   sig.internal_symbols = sig.f_count
   return sig
}

/*-----------------------------------------------------------------------
//
// Function: GlobalIndicesNull()
//
//   Set the global indices to NULL.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function GlobalIndicesNull( indices )
{
   indices.bw_rw_index   = NULL
   indices.pm_into_index = NULL
   indices.pm_negp_index = NULL
   indices.pm_from_index = NULL
   return indices
}

/* A node in the perfect discrimination tree... */

function typedef_struct_pdt_node_cell()
{
    function obj()
    {
        this.f_alternatives = new IntMap_p()
        this.v_alternatives = new PDArray_p()
        this.max_var = new FunCode()
        this.size_constr
        this.age_constr = new SysDate()
        this.pdt_node_cellparent
        this.ref_count
        this.entries = new PTree_p()
        this.variable = new Term_p()
        this.bound
        this.trav_count = new FunCode()
    }
    return obj
}
var PDTNodeCell = typedef_struct_pdt_node_cell()
var PDTNode_p = typedef_struct_pdt_node_cell()

function typedef_struct_pd_tree_cell()
{
    function obj()
    {
        this.tree = new PDTNode_p()
        this.term_stack = new PStack_p()
        this.term_proc = new PStack_p()
        this.tree_pos = new PDTNode_p()
        this.store_stack = new PStack_p()
        this.term = new Term_p()
        this.term_date = new SysDate()
        this.term_weight
        this.prefer_general
        this.node_count
        this.clause_count
        this.arr_storage_est
        this.longmatch_count
        this.longvisited_count
    }
    return obj
}
var PDTreeCell = typedef_struct_pd_tree_cell()
var PDTree_p = typedef_struct_pd_tree_cell()

var LONG_MAX = Infinity

/*-----------------------------------------------------------------------
//
// Function: PDTreeAlloc()
//
//   Allocate an empty, in initialized PDTreeCell (including the
//   initial PDTNodeCell().
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function PDTreeAlloc()
{
   var handle = new PDTree_p()
   handle = PDTreeCellAlloc(handle)
   handle.tree            = PDTNodeAlloc()
   handle.term_stack      = PStackAlloc()
   handle.term_proc       = PStackAlloc()
   handle.tree_pos        = NULL
   handle.store_stack     = NULL
   handle.term            = NULL
   handle.term_date       = SysDateCreationTime()
   handle.term_weight     = LONG_MAX
   handle.prefer_general  = 0  
   handle.clause_count    = 0
   handle.node_count      = 0 
   handle.arr_storage_est = 0
   handle.match_count     = 0
   handle.visited_count   = 0
   return handle
}

function PTreeCellAlloc(handle)
{
   return handle || SizeMalloc(PTreeCell)
}

/*-----------------------------------------------------------------------
//
// Function: push()
//
//   Implement push operation for pstacks. If the stack area needs to
//   grow, Realloc is emulated in terms of
//   SizeMalloc()/SizeFree(). This is because stacks are allocated and
//   deallocated a lot, and usually in the same sizes, so it pays off
//   to optimize this behaviour.
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function push( stack,val )
{
   if(stack.current == stack.size)
   {
      stack.size = stack.size*2
      stack.stack = realloc(stack.stack,IntOrP,stack.size)
   }
   stack.stack[stack.current] = val
   stack.current++
   return stack
}

/*-----------------------------------------------------------------------
//
// Function: PStackPushP()
//
//   Push a pointer onto the stack
//
// Global Variables: -
//
// Side Effects    : by push()
//
/----------------------------------------------------------------------*/

function PStackPushP( stack,val )
{
   var help = new IntOrP()
   help.p_val = val
   
   return push(stack, help)
}

function PStackEmpty(stack)
{
   return (stack.current == 0)
}

function PStackCellFree(junk)
{
   SizeFree(junk, PStackCell)
}

/*-----------------------------------------------------------------------
//
// Function: PStackFree()
//
//   Free a stack.
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function PStackFree( junk )
{
   console.log('PStackFree: junk ',junk,', .stack ',junk.stack)
   
   SizeFree(junk.stack, IntOrP, junk.size)
   PStackCellFree(junk)
}

/*-----------------------------------------------------------------------
//
// Function: PTreeInsertTree()
//
//   Insert elements stored in ADD into ROOT.
//
// Global Variables: -
//
// Side Effects    : Memory operations.
//
/----------------------------------------------------------------------*/

function PTreeInsertTree( root,add )
{
   var stack = new PStack_p()
   stack = PStackAlloc(stack)
   stack = PStackPushP(stack, add)
   while(!PStackEmpty(stack))
   {
      var next = PStackPopP(stack)
      if(next)
      {
         stack = PStackPushP(stack, next.lson)
         stack = PStackPushP(stack, next.rson)
         root = PTreeStore(root, next.key)
      }
   } 
   PStackFree(stack)
   return root
}

function PTreeCellFree(junk)
{
   return SizeFree(junk, PTreeCell)
}

/*-----------------------------------------------------------------------
//
// Function: PTreeStore()
//
//   Insert a cell with given key into the tree. Return FALSE if an
//   entry for this key exists, otherwise TRUE.
//
// Global Variables: -
//
// Side Effects    : Changes tree
//
/----------------------------------------------------------------------*/

function PTreeStore( root,key )
{
   var result = root
   var handle = new PTree_p()
   var newnode = new PTree_p()
   handle = PTreeCellAlloc(handle)
   handle.key = key
   var root = PTreeInsert(root, handle)
   if(root)
   {
      result = root
      PTreeCellFree(handle)
   } else {
      console.log('PTreeStore: *** warning*** - Unable to store key ( ',key,' ) in PTreeCell (root)')
   }
   return result
}

// __import(ccl_garbage_coll.h)
/*-----------------------------------------------------------------------
//
// Function: GCRegisterFormulaSet()
//
//   Register a formula set as containing relevant terms.
//
// Global Variables: -
//
// Side Effects    : Via PTReeStore()
//
/----------------------------------------------------------------------*/

function GCRegisterFormulaSet( gc,set )
{
   console.log('GCRegisterFormulaSet: gc ',gc,', set ',set)
   gc.formula_sets = PTreeStore(gc.formula_sets, set)
   return gc
}

function ProofStateAlloc( free_symb_prop )
{
   var handle = ProofStateCellAlloc()
   handle.signature            = SigAlloc()
   handle.signature = SigInsertInternalCodes( handle.signature )
   handle.original_symbols      = 0
   handle.original_terms        = TBAlloc( handle.signature )
   handle.terms                 = TBAlloc( handle.signature )
   handle.tmp_terms             = TBAlloc( handle.signature )
   handle.freshvars             = VarBankAlloc()
   handle.f_axioms              = FormulaSetAlloc()
   handle.f_ax_archive          = FormulaSetAlloc()
   handle.ax_archive            = ClauseSetAlloc()
   handle.axioms                = ClauseSetAlloc()
   handle.processed_pos_rules   = ClauseSetAlloc()
   handle.processed_pos_eqns    = ClauseSetAlloc()
   handle.processed_neg_units   = ClauseSetAlloc()
   handle.processed_non_units   = ClauseSetAlloc()
   handle.unprocessed           = ClauseSetAlloc()
   handle.tmp_store             = ClauseSetAlloc()
   handle.archive               = ClauseSetAlloc()
   handle.f_archive             = FormulaSetAlloc()
   handle.extract_roots         = PStackAlloc()
   handle.gindices              = GlobalIndicesNull( handle.gindices )
   handle.fvi_initialized       = false
   handle.fvi_cspec             = NULL
   handle.processed_pos_rules.demod_index = PDTreeAlloc()
   handle.processed_pos_eqns.demod_index  = PDTreeAlloc()
   handle.processed_neg_units.demod_index = PDTreeAlloc()
   handle.demods[0]             = handle.processed_pos_rules
   handle.demods[1]             = handle.processed_pos_eqns
   handle.demods[2]             = NULL
   handle.watchlist             = NULL
   handle.wlindices = GlobalIndicesNull( handle.wlindices )
   handle.state_is_complete     = true
   handle.definition_store      = DefStoreAlloc( handle.terms )
   handle.def_store_cspec       = NULL
   handle.gc_original_terms     = GCAdminAlloc( handle.original_terms )
   handle.gc_original_terms     = GCRegisterFormulaSet( handle.gc_original_terms,handle.f_axioms )
   handle.gc_original_terms     = GCRegisterFormulaSet( handle.gc_original_terms,handle.f_ax_archive )
   handle.gc_original_terms     = GCRegisterClauseSet( handle.gc_original_terms,handle.axioms )
   handle.gc_original_terms     = GCRegisterClauseSet( handle.gc_original_terms,handle.ax_archive )
   handle.gc_terms              = GCAdminAlloc( handle.terms )
   handle.gc_terms              = GCRegisterClauseSet( handle.gc_terms,handle.processed_pos_rules )
   handle.gc_terms              = GCRegisterClauseSet( handle.gc_terms,handle.processed_pos_eqns )
   handle.gc_terms              = GCRegisterClauseSet( handle.gc_terms,handle.processed_neg_units )
   handle.gc_terms              = GCRegisterClauseSet( handle.gc_terms,handle.processed_non_units )
   handle.gc_terms              = GCRegisterClauseSet( handle.gc_terms,handle.unprocessed )
   handle.gc_terms              = GCRegisterClauseSet( handle.gc_terms,handle.tmp_store )
   handle.gc_terms              = GCRegisterClauseSet( handle.gc_terms,handle.archive )
   handle.gc_terms              = GCRegisterClauseSet( handle.gc_terms,handle.definition_store.def_clauses )
   handle.gc_terms              = GCRegisterFormulaSet( handle.gc_terms,handle.definition_store.def_archive )
   handle.gc_terms              = GCRegisterFormulaSet( handle.gc_terms,handle.f_archive )
   handle.status_reported              = false
   handle.answer_count                 = 0
   handle.processed_count              = 0
   handle.proc_trivial_count           = 0 
   handle.proc_forward_subsumed_count  = 0 
   handle.proc_non_trivial_count       = 0
   handle.other_redundant_count        = 0
   handle.non_redundant_deleted        = 0
   handle.backward_subsumed_count      = 0
   handle.backward_rewritten_count     = 0
   handle.backward_rewritten_lit_count = 0
   handle.generated_count              = 0
   handle.generated_lit_count          = 0
   handle.non_trivial_generated_count  = 0
   handle.context_sr_count   = 0 
   handle.paramod_count      = 0
   handle.factor_count       = 0
   handle.resolv_count       = 0
   handle.signature.distinct_props = 
   handle.signature.distinct_props( ~free_symb_prop )
   
   return handle
}

// __import(cio_scanner.c)
function TokenType()
{
   this.value = arguments[0] || 0
}

function g_TPTtoken()
{
   this.NoToken       = 1
   this.WhiteSpace    = (2*this.NoToken)
   this.Comment       = (2*this.WhiteSpace)
   this.Ident         = (2*this.Comment)
   this.Idnum         = (2*this.Ident)
   this.SemIdent      = (2*this.Idnum)
   this.String        = (2*this.SemIdent)
   this.SQString      = (2*this.String)
   this.PosInt        = (2*this.SQString)
   this.OpenBracket   = (2*this.PosInt)
   this.CloseBracket  = (2*this.OpenBracket)
   this.OpenCurly     = (2*this.CloseBracket)
   this.CloseCurly    = (2*this.OpenCurly)
   this.OpenSquare    = (2*this.CloseCurly)
   this.CloseSquare   = (2*this.OpenSquare)
   this.LesserSign    = (2*this.CloseSquare)
   this.GreaterSign   = (2*this.LesserSign)
   this.EqualSign     = (2*this.GreaterSign)
   this.NegEqualSign  = (2*this.EqualSign)
   this.TildeSign     = (2*this.NegEqualSign)
   this.Exclamation   = (2*this.TildeSign)
   this.AllQuantor    = (this.Exclamation)
   this.QuestionMark  = (2*this.Exclamation)
   this.ExistQuantor  = (this.QuestionMark)
   this.Comma         = (2*this.QuestionMark)
   this.Semicolon     = (2*this.Comma)
   this.Colon         = (2*this.Semicolon)
   this.Hyphen        = (2*this.Colon)
   this.Plus          = (2*this.Hyphen)
   this.Mult          = (2*this.Plus)
   this.Fullstop      = (2*this.Mult)
   this.Dollar        = (2*this.Fullstop)
   this.Slash         = (2*this.Dollar)
   this.Pipe          = (2*this.Slash)
   this.FOFOr         = (this.Pipe)
   this.Ampersand     = (2*this.Pipe)
   this.FOFAnd        = (this.Ampersand)
   this.FOFLRImpl     = (2*this.Ampersand)
   this.FOFRLImpl     = (2*this.FOFLRImpl)
   this.FOFEquiv      = (2*this.FOFRLImpl)
   this.FOFXor        = (2*this.FOFEquiv)
   this.FOFNand       = (2*this.FOFXor)
   this.FOFNor        = (2*this.FOFNand)
   this.SkipToken     = (this.WhiteSpace|this.Comment)
   this.Identifier    = (this.Ident | this.Idnum)
   this.Name          = (this.Identifier |this.String)
   this.FOFBinOp      = (this.FOFAnd|this.FOFOr|this.FOFLRImpl|this.FOFRLImpl|this.FOFEquiv|this.FOFXor|this.FOFNand|this.FOFNor)
   this.FOFAssocOp    = (this.FOFAnd|this.FOFOr)
   this.LMultilineComment = (2*this.FOFNor)|this.Comment
   this.RMultilineComment = (2*this.LMultilineComment)
   this.Newline       = (2*this.RMultilineComment)
}

/* If your application parses multiple format you can use this to
   distinguish them: */

function typedef_enum_IOFormat()
{
    function obj()
    {
        this.LOPFormat = 1<<0
        this.TPTPFormat = 1<<1
        this.TSTPFormat = 1<<2
    }
    return obj
}
var IOFormat = typedef_enum_IOFormat()

function typedef_struct_dstrcell()
{
    function obj()
    {
        this.string
        this.len
        this.mem
        this.refs
    }
    return obj
}
var DStrCell = typedef_struct_dstrcell()
var DStr_p = typedef_struct_dstrcell()

function StreamType()
{
   this.value = arguments[0] || 0
}

function typedef_struct_tokencell()
{
   function obj(v)
   {
      return malloc({
         tok : new TokenType(),
         literal : new DStr_p(),
         longnumval,
         comment : new DStr_p(),
         skipped,
         source : new DStr_p(),
         stream_type : new StreamType(),
         line,
         column
      },v)
   }
   return obj
}
var TokenCell = typedef_struct_tokencell()
var Token_p = typedef_struct_tokencell()

var MAXTOKENLOOKAHEAD = 4 // max# bytes req'd for token
var MAXLOOKAHEAD = 64

/* Streams can read either from a file or from several predefined
   classes of strings. We use a StreamType 'virtual type' to denote
   this, because we can code this string type in a convenient way. */

function StreamType()
{
   this.value = arguments[0] || 0
}

function streamcell()
{
   this.value = arguments[0] || 0
}

/* The following data structure describes the state of a (named) input
   stream with look-a-head capability. Streams are stackable, with new
   data being read from the top of the stack. The empty stack is a
   NULL-valued pointer of type Inpstack_p! */

function typedef_struct_streamcell()
{
    function obj()
    {
        this.next = new streamcell()
        this.source = new DStr_p()
        this.stream_type = new StreamType()
        this.string_pos
        this.file = // new FILE()
        this.eof_seen
        this.line
        this.column
        this.buffer = new Array(MAXLOOKAHEAD)
        this.current
    }
    return obj
}
var StreamCell = typedef_struct_streamcell()
var Stream_p = typedef_struct_streamcell()
var Inpstack_p = typedef_struct_streamcell()

function typedef_struct_scannercell()
{
    function obj()
    {
        this.source = new Stream_p()
        this.default_dir = new DStr_p()
        this.format = new IOFormat()
        this.accu = new DStr_p()
        this.ignore_comments
        this.include_key
        this.tok_sequence = new TokenCell(MAXTOKENLOOKAHEAD)
        this.current
        this.include_pos
    }
    return obj
}
var ScannerCell = typedef_struct_scannercell()
var Scanner_p = typedef_struct_scannercell()

var StreamTypeFile = new StreamType()

// __import(clb_dstrings.c)
/*-----------------------------------------------------------------------
//
// Function: DStrReset()
//
//   Set the string to "" efficiently (does _not_ change internal
//   memory - call this to e.g. reinitialize a string in a loop) 
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function DStrReset( strdes )
{
   console.log('DStrReset: ', strdes)
   if(strdes.string)
   {
      strdes.string = ''
      strdes.len = 0
   }
   return strdes
}

var DSTRGROW = 64

function strlen(v)
{
   return v.length
}

/*-----------------------------------------------------------------------
//
// Function: DStrLen()
//
//   Return the length of a stored string (efficiency hack...)
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function DStrLen( strdes )
{
   console.log('DStrLen: strdes',strdes)
   return strdes.len
}

/*-----------------------------------------------------------------------
//
// Function: DStrAppendStr()
//
//   Append a C-String to a DStr efficiently
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function DStrAppendStr( strdes,newpart )
{
   var newlen
   var newmem
   
   console.log('DStrAppendStr: strdes ',strdes,', newpart ',newpart)
   
   newlen = strlen(newpart)
   newmem = strdes.mem
   
   while(strdes.len+newlen >= newmem) 
   {
      newmem += DSTRGROW
   }
   
   strdes.mem = newmem
   strdes.string += newpart
   strdes.len = newlen+strdes.string.length
   
   return strdes
}

/*-----------------------------------------------------------------------
//
// Function: DStrSet()
//
//   Set a dstring to a given C-String.
//
// Global Variables: -
//
// Side Effects    : Via DStrAppendStr()
//
/----------------------------------------------------------------------*/

function DStrSet( strdes,string )
{
   console.log('DStrSet: strdes ',strdes,', string ',string)
   strdes = DStrReset(strdes)
   strdes = DStrAppendStr(strdes,string)
   
   return strdes
}

var stdin = '<stdin>'

/*-----------------------------------------------------------------------
//
// Function: InputOpen()
//
//   Open an input file for reading. NULL and "-" are stdin. If fail
//   is TRUE then terminate with error, otherwise bubbles upward to next handler.
//
// Global Variables: -
//
// Side Effects    : No significant ones (I hope)
//
/----------------------------------------------------------------------*/

function InputOpen( name,fail )
{
   var _in_
   
   if(name && (name=="-"))
   {
      
      console.log("InputOpen: Trying file ", name)
      _in_ = srcCode.value // fopen(name, "r")
      if(fail && !_in_)
      {
         FileOpenErrorPrint(name)
      }
      if(fail)
      {
         console.log("InputOpen: Input file is ", name)
      }
   }
   else
   {
      console.log("InputOpen: Input source: <stdin>")
      _in_ = stdin
   }
   return _in_
}

function fclose(v)
{
   v= undefined
   return 0
}

function TmpErrn()
{
   this.value = arguments[0] || 0
}

/*-----------------------------------------------------------------------
//
// Function: InputClose()
//
//   Close an input file.
//
// Global Variables: -
//
// Side Effects    : As above ;-)
//
/----------------------------------------------------------------------*/

function InputClose( file )
{
   console.log("InputClose: Closing input")
   if(file != stdin)
   {
      fclose(file)
   }
}

var NullStr = ''

/*-----------------------------------------------------------------------
//
// Function: DStrView()
//
//   Return a pointer to the stored C-string. This is guaranteed to stay
//   fresh as long as no other DStr-Operation is performed on the
//   string. The user is responsible for the use of this pointer - in
//   particular, write-operations on the string should not change the
//   lenght of the string, or it will become corrupted!
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function DStrView( strdes )
{

   console.log('DStrView: strdes ',strdes)
   
   var result = NullStr
   
   if(strdes.string)
   {
      result = strdes
   }
   
   return result
}

/*-----------------------------------------------------------------------
//
// Function: read_char()
//
//   Read a character (line) and return it. Return an infinite sequence of
//   EOFs after the end of file.
//
// Global Variables: -
//
// Side Effects    : May read a character
//
/----------------------------------------------------------------------*/

function read_char( stream )
{
   var ch
   if(stream.eof_seen)
   {
      ch = NULL
   }
   else
   {
      if(stream.stream_type!=StreamTypeFile)
      {
         ch = DStrView(stream.source)[stream.string_pos]
         if(ch)
         {
            stream.string_pos++ // line_pos
         }
         else
         {
            ch = NULL
            stream.eof_seen = true
         }
      }
      else
      {
         ch = stream.file.split('\n') //getc(stream.file)
         if(ch == NULL)
         {
          stream.eof_seen = true
         }
      }
   }
   return { stream:stream, ch:ch }
}

/*-----------------------------------------------------------------------
//
// Function: CreateStream()
//
//   Create a stream associated with the file name. Both the
//   NULL-pointer and the name "-" are taken to mean stdin. 
//
// Global Variables: -
//
// Side Effects    : May terminate with an error message
//
/----------------------------------------------------------------------*/

function CreateStream( type,source,fail )
{
   var handle = new Stream_p()
   
   handle = StreamCellAlloc(handle)
   handle.source = DStrAlloc()
   handle.stream_type = type

   if(type == StreamTypeFile)
   {
      
      if(!source || (source != "-"))
      {
         handle.source = DStrSet(handle.source, "<stdin>")
         handle.file = stdin
      }
      else
      {
         handle.source = DStrSet(handle.source, source)
         handle.file = InputOpen(source, fail)
         if(!handle.file)
         {
            DStrFree(handle.source)
            StreamCellFree(handle)
            return NULL
         }
      }
      console.log("CreateStream: Opened ", DStrView(handle.source))
   }
   else
   {
      handle.source = DStrSet(handle.source, source)
      handle.string_pos = 0
   }
   
   handle.next       = NULL
   handle.eof_seen   = false
   handle.line       = 1
   handle.column     = 1
   handle.current    = 0
   
   var r = read_char(handle)
   handle.stream = r.stream
   handle.buffer = r.ch
   
   return handle
}

/*-----------------------------------------------------------------------
//
// Function: OpenStackedInput()
//
//   Open a new input stream and put it on top of the stack. All
//   further input from this stack is read from the new top of the
//   stack. 
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function OpenStackedInput( stack,type,source,fail )
{
   var handle = new Stream_p()
   handle = CreateStream(type, source, fail)
   if(handle)
   {   
      handle.next = stack
      stack = handle
   }
   return stack
}

function DStrLastChar(strdes)
{
   return DStrLen(strdes) ? DStrView(strdes)[DStrLen(strdes)-1]:NULL
}

/*-----------------------------------------------------------------------
//
// Function: SecureStrndup()
//
//   Implements the functionality of GNU strndup, but uses
//   SecureMalloc() for the memory handling (creates a NULL-terminated
//   copy of the string or the first n bytes of it).
//
// Global Variables: -
//
// Side Effects    : SecureMalloc()
//
/----------------------------------------------------------------------*/

function SecureStrndup( source,n )
{
   var res = source.split('')
   var handle = res.map(function(v,i){
      if((n>-1) && (i>n-1))
      {
         v = ''
      }
      return v
   })
   source = handle.join('')
   
   console.log('SecureStrndup: source ',source,', n>=0 ',n>=0)
   
   return source
}

/*-----------------------------------------------------------------------
//
// Function: FileNameDirName()
//
//   Given a path name, return the directory portion (i.e. the part
//   from the first character to the last / character (including
//   it). Return "" if no directory part exists. It is the users
//   responsibility to FREE the memory returned.
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function FileNameDirName( name )
{
   var res = name.split('\/')
   if(res[res.length-1])
   {
      res[res.length-1] = ''
   }
   res = res.join('\/')
   console.log('FileNameDirName: name ',res)
   
   return res
}

function FileNameIsAbsolute(name)
{
   return (name[0]=='/')
}

/*-----------------------------------------------------------------------
//
// Function: FileFindBaseName()
//
//   Return a pointer to the first character of the last file name
//   component of name. 
//
// Global Variables: 
//
// Side Effects    : 
//
/----------------------------------------------------------------------*/

function FileFindBaseName( name )
{
   var result = ''
   var res = name.split('/')
   if(res[res.length-1])
   {
      name = res[res.length-1]
   }
   return res
}

/*-----------------------------------------------------------------------
//
// Function: FileNameBaseName()
//
// Given a path, return a copy of the base name part of it, i.e. the
// string starting at the last / (if any). In contrast to the UNIX
// command 'basename', it will return the empty string for a string
// ending in "/".
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function FileNameBaseName( name )
{
   return FileFindBaseName(name)
}

function AktToken(_in_)
{
   return _in_.tok_sequence[_in_.current]
}

function DStrAppendChar(v,r)
{
   return DStrAppendStr(v,r)
}

function DStrDeleteLastChar(v)
{
   var result = v.split('')
   result[result.length-1] = ''
   return result.join('')
}

function free(v)
{
   v = undefined
}

function FREE(junk)
{
   free(junk)
}

/*-----------------------------------------------------------------------
//
// Function: DStrFree()
//
//   Decrease the reference counter. If it is equal to 0, free both
//   the DStr-Cell and the contained string. 
//
// Global Variables: -
//
// Side Effects    : Memory Operations
//
/----------------------------------------------------------------------*/

function DStrFree( junk )
{
   console.log(junk)
   console.log('DStrFree: junk.refs >= 1',junk.refs >= 1)
   junk.refs--
   if(!junk.refs)
   {
      if(junk.string)
      {
         FREE(junk.string)
      }
      DStrCellFree(junk)
   }
}

function DStrReleaseRef(strdes)
{
   if(strdes){
      DStrFree(strdes)
   }
}

function DStrGetRef(strdes)
{
   return (strdes ? ++strdes.refs:0)
}

function SourceType(scanner)
{
   return (scanner.source.stream_type)
}

function StreamCurrLine(stream)
{
   return (stream.line)
}

function CurrLine(scanner)
{
   return StreamCurrLine(scanner.source)
}

function StreamCurrColumn(stream)
{
   return (stream.column)
}

function CurrColumn(scanner)
{
   return StreamCurrColumn(scanner.source)
}

function StreamCurrChar(stream)
{
   return stream.buffer[stream.current]
}

function STREAMREALPOS(pos)
{
   return pos % MAXLOOKAHEAD
}

/*-----------------------------------------------------------------------
//
// Function: StreamNextChar()
//
//   Move the current window on the input stream one character
//   forward. Return the new CurrChar().
//
// Global Variables: -
//
// Side Effects    : Reads one character from the input, update the
//                   stream information about the current position.
//
/----------------------------------------------------------------------*/

function StreamNextChar( stream )
{
   if(StreamCurrChar(stream) == '\n')
   {
      stream.line++
      stream.column = 1
   }
   else
   {
      stream.column++
   }
   stream.current=STREAMREALPOS(stream.current+1)
   stream.buffer[STREAMREALPOS(stream.current+MAXLOOKAHEAD-1)]
      = read_char(stream)
   return StreamCurrChar(stream)
}

function  NextChar(scanner)
{
   return StreamNextChar(scanner.source)
}

var en = new g_TPTtoken()
var token_print_rep = {}
token_print_rep[en.NoToken]="No token (probably EOF)"
token_print_rep[en.WhiteSpace]="White space (spaces, tabs, newlines...)"
token_print_rep[en.Comment]="Comment"
token_print_rep[en.Ident]="Identifier not terminating in a number"
token_print_rep[en.Idnum]="Identifier terminating in a number"
token_print_rep[en.SemIdent]="Interpreted function/predicate name ('$name')"
token_print_rep[en.String]='String enclosed in double quotes ("")'
token_print_rep[en.SQString]="String enclosed in single quote ('')"
token_print_rep[en.PosInt]="Integer (sequence of decimal digits) convertable to an 'unsigned long'" 
   /* May need LargePosInt here... */
token_print_rep[en.OpenBracket]="Opening bracket '('"
token_print_rep[en.CloseBracket]="Closing bracket ')'"
token_print_rep[en.OpenCurly]="Opening curly brace '{en.'"
token_print_rep[en.CloseCurly]="Closing curly brace '}'"
token_print_rep[en.OpenSquare]="Opening square brace '['"
token_print_rep[en.CloseSquare]="Closing square brace ']'"
token_print_rep[en.LesserSign]='Less than" sign ("<")'
token_print_rep[en.GreaterSign]='Greater than" sign (">")'
token_print_rep[en.EqualSign]="Equal Predicate/Sign ('=')"
token_print_rep[en.NegEqualSign]="Negated Equal Predicate ('!=')"
token_print_rep[en.TildeSign]="Tilde ('~')"
token_print_rep[en.Exclamation]="Exclamation mark ('!')"
token_print_rep[en.QuestionMark]="Question mark ('?')"
token_print_rep[en.Comma]="Comma (',')"
token_print_rep[en.Semicolon]="Semicolon (';')"
token_print_rep[en.Colon]="Colon (':')"
token_print_rep[en.Hyphen]="Hyphen ('-')"
token_print_rep[en.Plus]="Plus sign ('+')"
token_print_rep[en.Mult]="Multiplication sign ('*')"
token_print_rep[en.Fullstop]="Fullstop ('.')"
token_print_rep[en.Dollar]="Dollar sign ('$')"
token_print_rep[en.Slash]="Slash ('/')"
token_print_rep[en.Pipe]="Vertical bar ('|')"
token_print_rep[en.Ampersand]="Ampersand ('&')"
token_print_rep[en.FOFLRImpl]="Implication/LRArrow ('=>')"
token_print_rep[en.FOFRLImpl]="Back Implicatin/RLArrow ('<=')"
token_print_rep[en.FOFEquiv]="Equivalence/Double arrow ('<=>')"
token_print_rep[en.FOFXor]="Negated Equivalence/Xor ('<~>')"
token_print_rep[en.FOFNand]="Nand ('~&')"
token_print_rep[en.FOFNor]="Nor ('~|')"
token_print_rep[en.NoToken]=NULL
token_print_rep[en.FOFXor]="Negated Equivalence/Xor ('^')"
en = undefined

function STAppend()
{
   var length = 0
   var v = arguments[0]
   var s = arguments[1]
   var incr = arguments[2] || 1
   v.literal += s
   v.j += incr
   v.pos += incr
   return v
}

/*-----------------------------------------------------------------------
//
// Function: scan_token()
//
//   Scans a token into AktToken(_in_). Does _not_ move the
//   AktToken-pointer - this is done only for real (i.e. non white,
//   non-comment) tokens in the function NextToken().
//   The function assumes that *AktToken(_in_) is an initialized
//   TokenCell which does not contain any outside references.
//
//
// Global Variables: -
//
// Side Effects    : Reads input, may cause memory operations via
//                   DStr-Functions. 
//
/----------------------------------------------------------------------*/

function scan_token(_in_)
{
   var en = new g_TPTtoken()
   var n = AktToken(_in)
   var token_buffer = n.buffer.split('')
   var result = []
   var LENGTH = token_buffer.length
   var i = 0
   var j = 0
   var pos = 0
   var choose = {
      ' ':function() { var v = arguments[0]; v.tok = en.WhiteSpace; while( token_buffer[v.pos].match(/\s/) ){ v = STAppend(v,token_buffer[v.pos]) } v.literal = ' '; return v },
      '_':function() { var v = arguments[0]; v.tok = en.Ident; v.literal='_'; v.pos++; v.j++; return v },
      '#':function() { var v = arguments[0]; v.tok = en.Comment; while( token_buffer[v.pos] && token_buffer[v.pos].match(/[^\n]/) ){ v = STAppend(v,token_buffer[v.pos]) } v.comment += v.literal; v.literal=''; return v },
      '%':function() { var v = arguments[0]; v.tok = en.Comment; while( token_buffer[v.pos] && token_buffer[v.pos].match(/[^\n]/) ){ v = STAppend(v,token_buffer[v.pos]) } v.comment += v.literal; v.literal=''; return v },
      '"':function() { var v = arguments[0]; v.tok = en.String; v.literal = '"'; v.pos++; v.j++; while( token_buffer[v.pos] && token_buffer[v.pos].match(/[^\"]/) ){ v = STAppend(v,token_buffer[v.pos]) } return v },
      "'":function() { var v = arguments[0]; v.tok = en.SQString; v.literal = "'"; v.pos++; v.j++; while( token_buffer[v.pos] && token_buffer[v.pos].match(/[^\']/) ){ v = STAppend(v,token_buffer[v.pos]) } return v },
      '(':function() { var v = arguments[0]; v.tok = en.OpenBracket; v.literal='('; v.pos++; v.j++; return v },
      ')':function() { var v = arguments[0]; v.tok = en.CloseBracket; v.literal=')'; v.pos++; v.j++; return v },
      '{':function() { var v = arguments[0]; v.tok = en.OpenCurly; v.literal='{'; v.pos++; v.j++; return v },
      '}':function() { var v = arguments[0]; v.tok = en.CloseCurly; v.literal='}'; v.pos++; v.j++; return v },
      '[':function() { var v = arguments[0]; v.tok = en.OpenSquare; v.literal='['; v.pos++; v.j++; return v },
      ']':function() { var v = arguments[0]; v.tok = en.CloseSquare; v.literal=']'; v.pos++; v.j++; return v },
      '^':function() { var v = arguments[0]; v.tok = en.FOFXor; v.literal='^'; v.pos++; v.j++; return v },
      '<':function() { var v = arguments[0]; v.tok = en.LesserSign; v.literal='<'; v.pos++; v.j++; return v },
      '>':function() { var v = arguments[0]; v.tok = en.GreaterSign; v.literal='>'; v.pos++; v.j++; return v },
      '=':function() { var v = arguments[0]; v.tok = en.EqualSign; v.literal='='; v.pos++; v.j++; return v },
      '~':function() { var v = arguments[0]; v.tok = en.TildeSign; v.literal='~'; v.pos++; v.j++; return v },
      '!':function() { var v = arguments[0]; v.tok = en.Exclamation; v.literal='!'; v.pos++; v.j++; return v },
      '?':function() { var v = arguments[0]; v.tok = en.QuestionMark; v.literal='?'; v.pos++; v.j++; return v },
      ',':function() { var v = arguments[0]; v.tok = en.Comma; v.literal=','; v.pos++; v.j++; return v },
      ';':function() { var v = arguments[0]; v.tok = en.Semicolon; v.literal=';'; v.pos++; v.j++; return v },
      ':':function() { var v = arguments[0]; v.tok = en.Colon; v.literal=':'; v.pos++; v.j++; return v },
      '-':function() { var v = arguments[0]; v.tok = en.Hyphen; v.literal='-'; v.pos++; v.j++; return v },
      '+':function() { var v = arguments[0]; v.tok = en.Plus; v.literal='+'; v.pos++; v.j++; return v },
      '*':function() { var v = arguments[0]; v.tok = en.Mult; v.literal='*'; v.pos++; v.j++; return v },
      '.':function() { var v = arguments[0]; v.tok = en.Fullstop; v.literal='.'; v.pos++; v.j++; return v },
      '|':function() { var v = arguments[0]; v.tok = en.Pipe; v.literal='|'; v.pos++; v.j++;  return v},
      '/':function() { var v = arguments[0]; v.tok = en.Slash; v.literal='/'; v.pos++; v.j++; return v},
      '&':function() { var v = arguments[0]; v.tok = en.Ampersand; v.literal='&'; v.pos++; v.j++; return v },
      '$':function() { var v = arguments[0]; v.tok = en.Dollar; v.literal='$'; v.pos++; v.j++; return v },
      '<~>':function() { var v = arguments[0]; v.tok = en.FOFXor; v.literal='<~>'; v.pos += 3; v.j += 3; return v },
      '<=>':function() { var v = arguments[0]; v.tok = en.FOFEquiv; v.literal='<=>'; v.pos += 3; v.j += 3; return v },
      '<=':function() { var v = arguments[0]; v.tok = en.FOFRLImpl; v.literal='<='; v.pos += 2; v.j += 2; return v },
      '=>':function() { var v = arguments[0]; v.tok = en.FOFLRImpl; v.literal='=>'; v.pos += 2; v.j += 2; return v },
      '~|':function() { var v = arguments[0]; v.tok = en.FOFNor; v.literal='~|'; v.pos += 2; v.j += 2; return v },
      '&|':function() { var v = arguments[0]; v.tok = en.FOFNand; v.literal='&|'; v.pos += 2; v.j += 2; return v },
      '!=':function() { var v = arguments[0]; v.tok = en.NegEqualSign; v.literal='!='; v.pos += 2; v.j += 2; return v },
      '/*':function() { var v = arguments[0]; v.tok = en.LMultilineComment; v.comment='/*'; while( (token_buffer[v.pos] && token_buffer[v.pos+1]) && token_buffer[v.pos].match(/[^\*]/) && token_buffer[v.pos+1].match(/[^\/]/) ){ v = STAppend(v,token_buffer[v.pos]+token_buffer[v.pos+1],2) } v.comment += v.literal; v.literal=''; return v },
      '*/':function() { var v = arguments[0]; v.tok = en.RMultilineComment; v.comment='*/'; v.pos += 2; v.j += 2; return v },
      '//':function() { var v = arguments[0]; v.tok = en.Comment; v.comment='//'; v.pos += 2; v.j += 2; while( token_buffer[v.pos] && token_buffer[v.pos].match(/[^\n]/) ){ v = STAppend(v,token_buffer[v.pos]) } v.comment += v.literal; v.literal=''; return v },
      '\n':function() { var v = arguments[0]; v.tok = en.Newline; v.literal='\n'; v.pos++; v.i++; v.j=0; return v },
      'match_idAlphaNum':function(){ var v = arguments[0]; v.tok = en.SemIdent; v.literal = token_buffer[v.pos] + token_buffer[v.pos+1]; v.pos += 2; v.j += 2; while( token_buffer[v.pos] && token_buffer[v.pos].match(/[\w\d_]/) ){ v = STAppend(v,token_buffer[v.pos]) } return v },
      'match_digit':function(){ var v = arguments[0]; v.tok = en.Idnum; while( token_buffer[v.pos].match(/[\d\.]/) ){ v = STAppend(v,token_buffer[v.pos]) } return v },
      'match_id':function(){ var v = arguments[0]; v.tok = en.Identifier; while( token_buffer[v.pos].match(/[\w_]/i) ){ v = STAppend(v,token_buffer[v.pos]) } return v },
      'OnError':function(s) { throw 'scan_token: *** Error *** - Illegal token or character - '+s }
   } // choose {}
   while(pos<LENGTH)
   {
      var v = { tok:'',comment:'',literal:'',i:i,j:j,pos:pos }
      var ch00 = token_buffer[pos]
      var ch01 = token_buffer[pos+1]
      var ch02 = token_buffer[pos+2]
      if((ch00 && ch01 && ch02) &&
      choose[ch00+ch01+ch02])
      {
         v = choose[ch00+ch01+ch02](v)
      }
      else if((ch00 && ch01) && 
      ch00.match(/[\w_]/i) && 
      ch01.match(/[\w\d_]/i))
      {
         v = choose['match_idAlphaNum'](v)
      }
      else if((ch00 && ch01) &&
      choose[ch00+ch01])
      {
         v = choose[ch00+ch01](v)
      }
      else if(ch00 && ch00.match(/[\w_]/i))
      {
         v = choose['match_id'](v)
      }
      else if(ch00 && ch00.match(/\d/))
      {
         v = choose['match_digit'](v)
      }
      else if((ch00) &&
      choose[ch00])
      {
         v = choose[ch00](v)
      }
      else
      {
         choose['OnError'](token_buffer(pos))
      }
      
      if(v.tok)
      {
         var w            = new TokenCell(0)
         w.tok            = v.tok
         w.literal        = v.literal // DStrReset(v.literal)
         w.source         = DStrReleaseRef(v.source)
         w.source         = DStrGetRef(Source(_in))
         w.stream_type    = SourceType(_in)
         w.line           = i // CurrLine( _in_)
         w.column         = j // CurrColumn( _in_)
         w.comment        = v.comment // DStrAlloc()
         i = v.i
         j = v.j
         pos = v.pos
         result.push(w)
      }
      else
      {
        pos++
        j++
      }
      
   }
   _in_.tok_sequence[_in_.current].token_buffer = result
   return _in_
}

/*-----------------------------------------------------------------------
//
// Function: TestTok()
//
//   Compares the type of the given token with a list of possible
//   tokens. Possibilities are values of type TokenType, possibly
//   combined with the bitwise or operator '|'. The test is TRUE if
//   the given token matches atleast one type from the list.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function TestTok( akt,toks )
{
   return ((akt.tok & toks)!=0)
}

/*-----------------------------------------------------------------------
//
// Function: str_n_element()
//
//   Test whether the len'th index of str is contained in the set of
//   id strings (encoded in a single string with elements separated
//   by |). 
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function str_n_element( str,ids,len )
{
   var result = false
   if(str.match(ids)){
      result = true
   }
   return result
}

/*-----------------------------------------------------------------------
//
// Function: TestId()
//
//   Test whether a given token is of type identifier and is one of
//   a set of possible alternatives. This set is given as a single
//   C-String, alternatives are separated by the '|' character.
//
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function TestId( akt,ids )
{
   var en = new g_TPTtoken()
   if(!TestTok(akt, en.Identifier))
   {
      return false
   }
   return str_n_element(DStrView(akt.literal), ids,
      DStrLen(akt.literal))
}

function TestInpId(_in_, ids)
{
   return TestId(AktToken(_in_), ids)
}

/*-----------------------------------------------------------------------
//
// Function: scan_token_follow_includes()
//
//   Scan a token, follow include directives and pop back empty input
//   stream.
//
// Global Variables: -
//
// Side Effects    : Read input, manipulate streams.
//
/----------------------------------------------------------------------*/

function scan_token_follow_includes( _in_ )
{
   var en = new g_TPTtoken()
   _in_ = scan_token( _in_)
   if(_in_.include_key && (TestInpId(_in_, _in_.include_key)))
   {
      var name = new DStr_p()
      name = DStrAlloc(name)
      var tptp_source = getenv("TPTP")

      if(tptp_source)
      {
         name = DStrAppendStr(name, tptp_source)
         if(DStrLen(name) && (DStrView(name)[DStrLen(name)-1] !='/'))
         {
            name = DStrAppendChar(name,'/')
         }
      }
      _in_ = scan_token( _in_)
      _in_ = CheckInpTok(_in_, en.OpenBracket)
      _in_ = scan_token(_in_)
      _in_ = CheckInpTok(_in_, en.Identifier|en.String|en.SQString)
      if(TestInpTok(_in_, en.Identifier))
      {
         name = DStrAppendDStr(name, AktToken(_in_).literal)
      }
      else
      {
         name = DStrAppendStr(name, DStrView(AktToken(_in_).literal)+1)
         name = DStrDeleteLastChar(name)
      }
      _in_.source = OpenStackedInput((_in_.source), StreamTypeFile,
             DStrView(name), true)
      DStrFree(name)
      _in_ = scan_token_follow_includes(_in_)
   }
   else if(_in_.include_key && TestInpTok(_in_, en.NoToken))
   {
      if(_in_.source.next)
      {
         _in_.source = CloseStackedInput(_in_.source)
         _in_ = scan_token(_in_)
         _in_ = CheckInpTok(_in_, en.CloseBracket)
         _in_ = scan_token(_in_)
         _in_ = CheckInpTok(_in_, en.Fullstop)
         _in_ = scan_token_follow_includes(_in_)
      }      
   }
   return _in_
}

/*-----------------------------------------------------------------------
//
// Function: scan_real_token()
//
//   Scan tokens until a real token (i.e. not a SkipToken has been
//   scanned.
//
// Global Variables: -
//
// Side Effects    : Reads input, manipulates streams.
//
/----------------------------------------------------------------------*/

function scan_real_token( _in_ )
{
   var en = new g_TPTtoken()
   var v = AktToken(_in_)
   
   v.skipped = false
   v.comment = DStrReset(v.comment)
   
   _in_ = scan_token_follow_includes(_in_)
   v = AktToken( _in_ )
   
   while(TestTok(v, en.SkipToken))
   {
      v.skipped = true
      if(!_in_.ignore_comments && TestInpTok(_in_, en.Comment))
      {
         v.comment = DStrAppendDStr(v.comment, v.literal)
      }
      _in_ = scan_token_follow_includes(_in_)
      v = AktToken( _in_ )
   }
   _in_.tok_sequence[_in_.current] = v
   
   return _in_
}

/*-----------------------------------------------------------------------
//
// Function: CreateScanner()
//
//   Create a new initialized scanner to read tokens
//   immediately.
//
// Global Variables: -
//
// Side Effects    : Opens files, memory operations, reads input.
//
/----------------------------------------------------------------------*/

function CreateScanner( type,name,ignore_comments,default_dir)
{
   var en = new IOFormat()
   var vn = new g_TPTtoken()
   var handle = new Scanner_p()
   handle = ScannerCellAlloc(handle)
   var stream = new Stream_p()
   var tmp_name = ''
   
   handle.source = NULL
   handle.default_dir = DStrAlloc()
   handle.accu = DStrAlloc()
   handle.ignore_comments = ignore_comments
   handle.include_key = NULL
   handle.format = en.LOPFormat
   
   if(((type==StreamTypeFile) && (name=="-"))||
      (type != StreamTypeFile))
   {
      handle.source = OpenStackedInput(handle.source, type, name, true)
      console.log('CreateScanner: stream ',stream)
   }
   else
   {
      console.log('CreateScanner: type == StreamTypeFile ',type==StreamTypeFile)
      if(FileNameIsAbsolute(name))
      {
         handle.source = OpenStackedInput(handle.source, type, name, true)
         tmp_name = FileNameDirName(name)
         handle.default_dir = DStrAppendStr(handle.default_dir, tmp_name)
         FREE(tmp_name)
         console.log('CreateScanner: stream ',stream)
      }
      else
      {
         var full_file_name = new DStr_p()
         full_file_name = DStrAlloc(full_file_name)
         
         if(default_dir)
         {
            handle.default_dir = DStrAppendStr(handle.default_dir, default_dir)
            console.log('CreateScanner: DStrLen ',!DStrLen(handle.default_dir)||
                   DStrLastChar(handle.default_dir) =='/')
         }
         tmp_name = FileNameDirName(name)
         handle.default_dir = DStrAppendStr(handle.default_dir, tmp_name)
         console.log('CreateScanner: handle.default_dir=0 ',DStrLen(handle.default_dir)==0,'handle.default_dir=/ ',DStrLastChar(handle.default_dir) =='/')
         FREE(tmp_name)
         tmp_name = FileNameBaseName(name)
         full_file_name = DStrAppendStr(full_file_name, 
                       DStrView(handle.default_dir))
         full_file_name = DStrAppendStr(full_file_name, 
                       tmp_name)
         FREE(tmp_name)
         handle.source = OpenStackedInput(handle.source, type, 
                                   DStrView(full_file_name), !TPTP_dir)
         if(!handle.source)
         {
            console.log('CreateScanner: TPTP_dir ',TPTP_dir)
            handle.default_dir = DStrSet(handle.default_dir, TPTP_dir)
            tmp_name = FileNameDirName(name)
            handle.default_dir = DStrAppendStr(handle.default_dir, tmp_name)
            FREE(tmp_name)            
            tmp_name = FileNameBaseName(name)
            full_file_name = DStrSet(full_file_name, 
                    DStrView(handle.default_dir))
            full_file_name = DStrAppendStr(full_file_name, tmp_name)
            FREE(tmp_name)
            handle.source = OpenStackedInput(handle.source, type, DStrView(full_file_name), true)
         }
         DStrFree(full_file_name)
      }
   }
   
   for(handle.current = 0; handle.current<MAXTOKENLOOKAHEAD; handle.current++)
   {
      handle.tok_sequence[handle.current].tok = vn.NoToken
      handle.tok_sequence[handle.current].literal = DStrAlloc()
      handle.tok_sequence[handle.current].comment = DStrAlloc()
      handle.tok_sequence[handle.current].source      = NULL
      handle.tok_sequence[handle.current].stream_type = NULL
      handle = scan_token(handle) // scan_real_token(handle)
   }
   
   handle.current = 0
   handle.include_pos = NULL
   
   return handle
}

var Verbose

function VERBOSE(arg) 
{
   if(Verbose)
   {
      console.log('verbose: ',arg)
   }
}

function VERBOSE2(arg) 
{
   if(Verbose>=2)
   {
      console.log('verbose2: ',arg)
   }
}

function VERBOSE10(arg) 
{
   if(Verbose>=10)
   {
      arg
   }
}

function VERBOUT(arg) 
{
   if(Verbose)
   {
      console.log('verbout: ',arg)
   }
}

function VERBOUT2(arg) 
{
   if(Verbose)
   {
      console.log('verbout2: ',arg)
   }
}

function VERBOUT10(arg)
{
   if(Verbose)
   {
      console.log('verbout10: ',arg)
   }
}

function VERBOUTARG(arg1,arg2)
{
   if(Verbose)
   {
      console.log('verboutarg: ',arg,arg2)
   }
}

function VERBOUTARG2(arg1,arg2)
{
   if(Verbose)
   {
      console.log('verboutarg2: ',arg,arg2)
   }
}

function ClauseSetProp(clause, prop)
{
   return SetProp((clause), (prop))
}

function ClauseDelProp(clause, prop)
{
   return DelProp((clause), (prop))
}

/*-----------------------------------------------------------------------
//
// Function: ClauseSetTPTPType()
//
//   Set the TPTP type of a clause. 
//
// Global Variables: 
//
// Side Effects    : 
//
/----------------------------------------------------------------------*/

function ClauseSetTPTPType( clause,type )
{
   clause = ClauseDelProp(clause,CPTypeMask)
   return ClauseSetProp(clause, type)
}

/*-----------------------------------------------------------------------
//
// Function: ClauseParse()
//
//   Parse a clause.
//
// Global Variables: ClausesHaveLocalVariables,
//                   ClausesHaveDisjointVariables 
//
// Side Effects    : Input, memory operations,
//         This is hairy! E's internal types do not map very well to
//         TSTP types, and E uses the "initial" properties in ways that
//         make it highly desirable that anything in the input is
//         actually initial (the CPInitialProperty is actually set in
//         all clauses in the initial unprocessed clause set. 
/----------------------------------------------------------------------*/

function ClauseParse(_in_,bank)
{
   var en = new g_TPTtoken()
   var concl = new Eqn_p()
   var precond = new Eqn_p()
   var procedural = false
   var type = new ClauseProperties()
   type = CPTypeAxiom(type)
   var input = new ClauseProperties()
   input = CPInputClause(input)
   var handle = new Clause_p()
   var info = new ClauseInfo_p()
   
   if(ClausesHaveLocalVariables)
   {
      VarBankClearExtNames(bank.vars)
   }  
   if(ClausesHaveDisjointVariables)
   {
      VarBankClearExtNamesNoReset(bank.vars)
   }
   info = ClauseInfoAlloc(NULL, DStrView(AktToken(_in_).source),
                          AktToken(_in_).line, AktToken(_in_).column); 
   if(ScannerGetFormat(_in_) == TPTPFormat)
   {      
      AcceptInpId(_in_, "input_clause")
      AcceptInpTok(_in_, en.OpenBracket)
      info.name = DStrCopy(AktToken(_in_).literal)
      AcceptInpTok(_in_, en.Name)
      AcceptInpTok(_in_, en.Comma)
      type = ClauseTypeParse(_in_, "axiom|hypothesis|conjecture|lemma|unknown|watchlist")
      if(type == CPTypeConjecture)
      {
         type = CPTypeNegConjecture; 
      }
      AcceptInpTok(_in_, en.Comma)
      AcceptInpTok(_in_, en.OpenSquare)
      concl = EqnListParse(_in_, bank, en.Comma)
      AcceptInpTok(_in_, en.CloseSquare)
      AcceptInpTok(_in_, en.CloseBracket);   
   }
   else if(ScannerGetFormat(_in_) == TSTPFormat)
   {
      AcceptInpId(_in_, "cnf")
      AcceptInpTok(_in_, en.OpenBracket)
      info.name = DStrCopy(AktToken(_in_).literal)
      AcceptInpTok(_in_, en.Name|en.PosInt|en.SQString)
      AcceptInpTok(_in_, en.Comma)
      type = ClauseTypeParse(_in_, 
                             "axiom|definition|theorem|assumption|"
                             "hypothesis|negated_conjecture|"
                             "lemma|unknown|plain|watchlist")
      AcceptInpTok(_in_, en.Comma)
      if(TestInpTok(_in_, en.OpenBracket))
      {
         AcceptInpTok(_in_, en.OpenBracket)
         concl = EqnListParse(_in_, bank, en.Pipe)
         AcceptInpTok(_in_, en.CloseBracket)
      }
      else
      {
         concl = EqnListParse(_in_, bank, en.Pipe)
      }
      if(TestInpTok(_in_, en.Comma))
      {
         AcceptInpTok(_in_, en.Comma)
         TSTPSkipSource(_in_)
         if(TestInpTok(_in_, en.Comma))
         {
            AcceptInpTok(_in_, en.Comma)
            CheckInpTok(_in_, en.OpenSquare)
            ParseSkipParenthesizedExpr(_in_)
         }
      }
      AcceptInpTok(_in_, en.CloseBracket)
   }
   else
   {
      concl = EqnListParse(_in_, bank, en.Semicolon)
      if(TestInpTok(_in_, en.Colon))
      {
          if(EqnListLength(concl)>1)
          {
          AktTokenError(_in_, 
                   "Procedural rule cannot have more than one "
                   "head literal",
                   false)
          }
          procedural = true
      }
      else if(TestInpTok(_in_, en.QuestionMark))
      {
          if(EqnListLength(concl)>0)
          {
             AktTokenError(_in_, 
                 "Query should consist only of tail literals",
                 false)
          }
          type = CPTypeNegConjecture
          
      }
      if(TestInpTok(_in_, en.Fullstop))
      {
          if(EqnListLength(concl)>1)
          {
             AktTokenError(_in_, 
                 "Procedural fact cannot have more than one "
                 "literal",
                 false)
          }
          procedural = true
      }
      else
      {
          AcceptInpTok(_in_, en.LesserSign|en.Colon|en.QuestionMark)
          AcceptInpTokNoSkip(_in_, en.Hyphen)
          
          precond = EqnListParse(_in_, bank, en.Comma)
          
          if(procedural && EqnListLength(precond)==0)
          {
             AktTokenError(_in_, 
                 "Procedural rule or query needs at least one "
                 "tail literal (Hey! I did not make this "
                 " syntax! -StS)", 
                 false)
          }
          precond = EqnListNegateEqns(precond)
          concl = EqnListAppend(concl, precond)
      }
   }
   AcceptInpTok(_in_, en.Fullstop)
   handle = ClauseAlloc(concl)
   handle = ClauseSetTPTPType(handle, type)
   handle = ClauseSetProp(handle, CPInitial|input)
   handle.info = info
   
   return handle
}

/*-----------------------------------------------------------------------
//
// Function: ClauseSetParseList()
//
//   Parse a list of clauses into the set. Clauses are not
//   evaluated. Returns number of clauses parsed.
//
// Global Variables: Only for parsing of terms.
//
// Side Effects    : Input, memory operations, changes set.
//
/----------------------------------------------------------------------*/

function ClauseSetParseList( _in_,set,bank )
{
   var count = 0
   var clause = new Clause_p()
   
   while(ClauseStartsMaybe(_in_))
   {
      clause = ClauseParse(_in_, bank)
      count++
      set = ClauseSetInsert(set, clause)
   }
   return count
}

/*-----------------------------------------------------------------------
//
// Function: PosRep()
//
//   Return a pointer to a description of a position in a file. The
//   description is valid until the function is called the next time.
//
// Global Variables: -
//
// Side Effects    : Sets static variable
//
/----------------------------------------------------------------------*/

function PosRep( type,source,line,column )
{
   var buff = ''
   var tmp_str = ''
   if(type == StreamTypeFile)
   {
      console.log('PosRep: ',strlen(DStrView(source))<=MAXPATHLEN)
      buff = DStrView(source)+': '+line+':(column '+column+'):'
      console.log('PosRep: ',buff)
   }
   else
   {
      tmp_str = '\0'
      tmp_str += type
      tmp_str += ": \""
      tmp_str += DStrView(source)
      if(strlen(DStrView(source))>MAXPATHLEN-4)
      {
         tmp_str += "..."
      }
      tmp_str += "\""
      buff = tmp_str+': '+line+':(column '+column+'):'
      console.log('PosRep: ',buff)
   }
   
   return buff
}

/*-----------------------------------------------------------------------
//
// Function: TokenPosRep()
//
//   Return a pointer to a description of the position of a token. The
//   description is valid until the function or PosRep() is called the
//   next time. 
//
// Global Variables: -
//
// Side Effects    : By PosRep()
//
/----------------------------------------------------------------------*/

function TokenPosRep( token )
{
  return PosRep(token.stream_type, token.source, token.line, token.column)
}

/*-----------------------------------------------------------------------
//
// Function: AcceptDottedId()
//
//   Parse a sequence id1.id2.id2..., check it against an expected
//   value, and skip it. Print error and terminate on mismatch.
//
// Global Variables: -
//
// Side Effects    : Input, memory ops.
//
/----------------------------------------------------------------------*/

function AcceptDottedId( _in_,expected )
{
   var err = new ErrorCodes()
   var candidate
   var posrep = TokenPosRep(AktToken(_in_))
   
   candidate = ParseDottedId(_in_)
   if(candidate==expected)
   {
      throw err.SYNTAX_ERROR+' '+posrep+' expected '+expected+'. Next candidate: '+candidate
   }
   FREE(candidate)
}

/*-----------------------------------------------------------------------
//
// Function: DStrCopyCore()
//
//   Return a pointer to a copy of the stored string without the first
//   and last character (this is useful for stripping quotes off
//   string literals). The user is responsible for freeing the memory
//   (via free()/FREE()). Fails if string has less than two characters.
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function DStrCopyCore( strdes )
{
   strdes.string = strdes.string.replace(/['"]/gmi,'')
   strdes.len = strdes.string.length
   console.log('DStrCopyCore: ',strdes)
   console.log('DStrCopyCore: ',strdes.string)
   console.log('DStrCopyCore: ',strdes.len >= 2)
   return strdes
}

function ScannerSetFormat(scanner, fmt)
{
   scanner.format = (fmt)
   return scanner
}

function TOKENREALPOS(pos)
{
   return (pos) % MAXTOKENLOOKAHEAD
}

/*-----------------------------------------------------------------------
//
// Function: NextToken()
//
//   Read a new token, switch to the next token in the queue.
//
// Global Variables: -
//
// Side Effects    : Only by calling scan_real_token()
//
/----------------------------------------------------------------------*/

function NextToken( _in_ )
{
   scan_real_token(in)
   _in_.current = TOKENREALPOS(in.current+1)
   return _in_
}

/*-----------------------------------------------------------------------
//
// Function: ScannerParseInclude()
//
//   Parse a TPTP-Style include statement. Return a scanner for the
//   included file, and put (optional) selected names into
//   name_selector. If the file name is in skip_includes, skip the
//   rest and return NULL. 
//
// Global Variables: -
//
// Side Effects    : Reads input.
//
/----------------------------------------------------------------------*/

function ScannerParseInclude( _in_,name_selector,skip_includes )
{
   var en = new g_TPTtoken()
   var new_scanner = new Scanner_p()
   var name
   var pos_rep
   
   pos_rep = SecureStrdup(TokenPosRep(AktToken(_in_)))
   AcceptInpId(_in_, "include")
   AcceptInpTok(_in_, en.OpenBracket)
   CheckInpTok(_in_, en.SQString)
   name = DStrCopyCore(AktToken(_in_).literal)
   
   if(!StrTreeFind(skip_includes, name))
   {
      new_scanner = CreateScanner(StreamTypeFile, name, 
                                  _in_.ignore_comments, 
                                  ScannerGetDefaultDir(_in_));   
      new_scanner = ScannerSetFormat(new_scanner, ScannerGetFormat(_in_))
      new_scanner.include_pos = pos_rep
   }
   else
   {
      FREE(pos_rep)
   }
   FREE(name)
   _in_ = NextToken(_in_)
   if(TestInpTok(_in_, en.Comma))
   {
      var dummy = new IntOrP()
      
      dummy.i_val = 0
      _in_ = NextToken(_in_)
      _in_ = CheckInpTok(_in_, en.Name|en.PosInt|en.OpenSquare)
      
      if(TestInpTok(_in_, en.Name|en.PosInt))
      {
         name_selector = StrTreeStore(
            name_selector, 
            DStrView(AktToken(_in_).literal),
            dummy, 
            dummy)
         _in_ = NextToken(_in_)
      }
      else
      {
         _in_ = AcceptInpTok(_in_, en.OpenSquare)
         if(!TestInpTok(_in_, en.CloseSquare))
         {            
            name_selector = StrTreeStore(name_selector, DStrView(AktToken(_in_).literal),
                         dummy, dummy)
            _in_ = AcceptInpTok(_in_, en.Name|en.PosInt)
            while(TestInpTok(_in_, en.Comma))
            {
               _in_ = NextToken(_in_)
               name_selector = StrTreeStore(name_selector, DStrView(AktToken(_in_).literal),
                            dummy, dummy)
               _in_ = AcceptInpTok(_in_, en.Name|en.PosInt)
            }
         }
         else 
         {
            dummy.i_val = 1
            name_selector = StrTreeStore(name_selector, "** Not a legal name**",
                         dummy, dummy)
            
         }
         _in_ = AcceptInpTok(_in_, en.CloseSquare)
      }      
   }
   _in_ = AcceptInpTok(_in_, en.CloseBracket)
   _in_ = AcceptInpTok(_in_, en.Fullstop)
   return new_scanner
}

/*-----------------------------------------------------------------------
//
// Function: EvalCompare()
//
//   Compare two evaluations, return a value <0, =0 or >0 if the first
//   one is smaller than, equal two, or bigger than the second one.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function EvalCompare( ev1,ev2,pos )
{
   var res = ev1.evals[pos].priority - ev2.evals[pos].priority
   var result
   if(res)
   {
      result = res
   }
   else if(ev1.eval_count==ev2.eval_count)
   {
      result = 0
   }
   else if(ev1.evals[pos].heuristic<ev2.evals[pos].heuristic)
   {
      console.log(ev1.eval_count!=ev2.eval_count)
      result = -1
   }
   else if(ev1.evals[pos].heuristic>ev2.evals[pos].heuristic)
   {
      console.log(ev1.eval_count!=ev2.eval_count)
      result = 1
   }
   else
   {
      result = ev1.eval_count - ev2.eval_count
   }
   return result
}

/*-----------------------------------------------------------------------
//
// Function: EvalTreeInsert()
//
//   If an entry with newnode exists in the tree return a
//   pointer to it. Otherwise insert newnode in the tree and return
//   NULL. 
//
// Global Variables: -
//
// Side Effects    : Changes the tree
//
/----------------------------------------------------------------------*/

function EvalTreeInsert( root,newnode,pos )
{
   var cmpres
   var result
   if (!root)
   {
      newnode.evals[pos].lson = newnode.evals[pos].rson = NULL
      root = newnode
      result = NULL
   }
   else
   {
      root = splay_tree(root, newnode, pos)
      cmpres = EvalCompare(newnode, root, pos)
      
      if (cmpres < 0)
      {
         newnode.evals[pos].lson = root.evals[pos].lson
         newnode.evals[pos].rson = root
         root.evals[pos].lson = NULL
         root = newnode
         return NULL
      } 
      else if(cmpres > 0)
      {
         newnode.evals[pos].rson = root.evals[pos].rson
         newnode.evals[pos].lson = root
         root.evals[pos].rson = NULL
         root = newnode
         return NULL
      }
      else
      {
         result = root
      }
   }
   return result
}

function ClauseLiteralNumber(clause)
{
   return clause.pos_lit_no+clause.neg_lit_no
}

function PDArrayElementP(array, idx)
{
   return PDArrayElementRef(array, idx).p_val
}

/*-----------------------------------------------------------------------
//
// Function: ClauseSetInsert() 
//
//   Insert a clause as the last clause into the clauseset.
//
// Global Variables: -
//
// Side Effects    : Changes set
//
/----------------------------------------------------------------------*/

function ClauseSetInsert( set,newclause )
{
   var root = new Eval_p()
   console.log('ClauseSetInsert :',!newclause.set)
   newclause.succ = set.anchor
   newclause.pred = set.anchor.pred
   set.anchor.pred.succ = newclause
   set.anchor.pred = newclause
   newclause.set = set
   set.members++
   set.literals+=ClauseLiteralNumber(newclause)
   if(newclause.evaluations)
   {
      for(var i=0; i<newclause.evaluations.eval_no; i++)
      {
         root = PDArrayElementP(newclause.set.eval_indices,i))
         set.evaluations = EvalTreeInsert(root, newclause.evaluations, i)
      }
      set.eval_no = Math.max(newclause.evaluations.eval_no, set.eval_no)
   }
   return set
}

/*-----------------------------------------------------------------------
//
// Function: clause_set_extract_entry()
//
//   Remove a plain clause from a plain clause set.
//
// Global Variables: -
//
// Side Effects    : Changes set
//
/----------------------------------------------------------------------*/

function  clause_set_extract_entry( clause )
{
   var root = new Eval_p ()
   
   if(clause.evaluations)
   {
      for(var i=0; i<clause.evaluations.eval_no; i++)
      {
         root = PDArrayElementP(clause.set.eval_indices, i)
            clause.evaluations = EvalTreeExtractEntry(root,
                                 clause.evaluations,
                                 i); 
      }
   }
   clause.pred.succ = clause.succ
   clause.succ.pred = clause.pred
   clause.set.literals-=ClauseLiteralNumber(clause)
   clause.set.members--
   clause.set = NULL
   clause.succ = NULL
   clause.pred = NULL
   return clause
}

/*-----------------------------------------------------------------------
//
// Function: ClauseSetExtractEntry()
//
//   Remove a (possibly indexed) clause from a clause set.
//
// Global Variables: -
//
// Side Effects    : Changes set
//
/----------------------------------------------------------------------*/

function ClauseSetExtractEntry( clause )
{
   var en = new ClauseProperties()
   console.log('ClauseSetExtractEntry: clause ',clause)
   console.log('ClauseSetExtractEntry: clause.set ',clause.set)
   
   if(ClauseQueryProp(clause, CPIsDIndexed))
   {
      console.log('ClauseSetExtractEntry: clause.set.demod_index ',clause.set.demod_index)
      if(clause.set.demod_index)
      {
         console.log('ClauseSetExtractEntry: ClauseIsUnit(clause) ',ClauseIsUnit(clause))
         clause.set.demod_index = PDTreeDelete(clause.set.demod_index, clause.literals.lterm,clause)
         if(!EqnIsOriented(clause.literals))
         {
            clause.set.demod_index = PDTreeDelete(clause.set.demod_index,
               clause.literals.rterm, clause)
         }
         clause = ClauseDelProp(clause, en.CPIsDIndexed)
      }
   }
   if(ClauseQueryProp(clause, en.CPIsSIndexed))
   {
      clause = FVIndexDelete(clause.set.fvindex, clause)
      clause = ClauseDelProp(clause, en.CPIsSIndexed)
   }
   return clause_set_extract_entry(clause)
}

/*-----------------------------------------------------------------------
//
// Function: ClauseSetExtractFirst()
//
//   Extract the first element of the set and return it. Return NULL
//   if set is empty.
//
// Global Variables: -
//
// Side Effects    : As above
//
/----------------------------------------------------------------------*/

function ClauseSetExtractFirst( set )
{
   var result
   var handle = new Clause_p()
   if(ClauseSetEmpty(set))
   {
      result = NULL
   }
   else
   {
      handle = set.anchor.succ
      console.log('ClauseSetExtractFirst: handle.set == set - ',handle.set == set)
      result = ClauseSetExtractEntry(handle)
   }
   return result
}

/*-----------------------------------------------------------------------
//
// Function: ClauseSetInsertSet()
//
//   Move all clauses from from into set (leaving from empty, but not
//   deleted). 
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function ClauseSetInsertSet( set,from )
{
   var handle = new Clause_p()
   var res = 0
   
   while(!ClauseSetEmpty(from))
   {
      handle = ClauseSetExtractFirst(from)
      set = ClauseSetInsert(set, handle)
      res++
   }
   return { set:set,res:res }
}

function StrTreeFree(v)
{
   FREE(v)
}

function ClauseSetFree(v)
{
   FREE(v)
}

function FormulaSetFree(v)
{
   FREE(v)
}

var ClausesHaveDisjointVariables = false

/*-----------------------------------------------------------------------
//
// Function: VarBankClearExtNamesNoReset()
//
//   Reset the External name -> FunCode association state, but do not
//   reset the variable counter
//
// Global Variables: -
//
// Side Effects    : Memory operations
//
/----------------------------------------------------------------------*/

function VarBankClearExtNamesNoReset( vars )
{
   StrTreeFree(vars.ext_index)
   vars.ext_index = NULL
   return vars
}

var global_formula_counter = 0

/*-----------------------------------------------------------------------
//
// Function: WTFormulaAlloc()
//
//   Allocate a wrapped formula given the essential information. id
//   will automagically be set to a new value.
//
// Global Variables: FormulaIdentCounter
//
// Side Effects    : Via DefaultWFormulaAlloc()
//
/----------------------------------------------------------------------*/

function WTFormulaAlloc( terms,formula )
{
   var handle = new WFormula_p()
   handle = DefaultWFormulaAlloc(handle)
   
   handle.terms = terms
   handle.tformula = formula
   handle.ident = ++global_formula_counter
   
   return handle
}

/*-----------------------------------------------------------------------
//
// Function: WFormulaTPTPParse()
//
//   Parse a formula in TPTP format.
//
// Global Variables: -
//
// Side Effects    : Input
//
/----------------------------------------------------------------------*/

function WFormulaTPTPParse(_in_,terms)
{
   var en = new g_TPTtoken()
   var vn = new WFormulaProperties()
   var tform = new TFormula_p()
   var type = new WFormulaProperties()
   var handle = new WFormula_p()
   var info = new ClauseInfo_p()
   info = ClauseInfoAlloc(NULL, DStrView(AktToken(_in_).source), 
                          AktToken(_in_).line, 
                          AktToken(_in_).column); 
   _in_ = AcceptInpId(_in_, "input_formula")
   _in_ = AcceptInpTok(_in_, en.OpenBracket);  
   _in_ = CheckInpTok(_in_, en.Name|en.PosInt)
   info.name = DStrCopy(AktToken(_in_).literal)
   _in_ = NextToken(_in_)
   _in_ = AcceptInpTok(_in_, Comma)
   _in_ = CheckInpId(_in_, "axiom|hypothesis|negated_conjecture|conjecture|question|lemma|unknown")
   if(TestInpId(_in_, "conjecture"))
   {
      type = vn.WPTypeConjecture
   }
   else if(TestInpId(_in_, "question"))
   {
      type = vn.WPTypeQuestion
   }
   else if(TestInpId(_in_, "negated_conjecture"))
   {
      type = vn.WPTypeNegConjecture
   }
   else if(TestInpId(_in_, "hypothesis"))
   {
      type = vn.WPTypeHypothesis
   }
   else
   {
      type = vn.WPTypeAxiom
   }
   _in_ = NextToken(_in_)
   _in_ = AcceptInpTok(_in_, en.Comma)
   tform = TFormulaTPTPParse(_in_, en.terms)
   handle = WTFormulaAlloc(terms, tform)
   _in_ = AcceptInpTok(_in_, en.CloseBracket)
   _in_ = AcceptInpTok(_in_, en.Fullstop)
   handle = FormulaSetType(handle, type)
   handle = FormulaSetProp(handle, vn.WPInitial|vn.WPInputFormula)
   handle.info = info

   return { handle:handle,_in_:_in_ }
}

/*-----------------------------------------------------------------------
//
// Function: WFormulaTSTPParse()
//
//   Parse a formula in TSTP format.
//
// Global Variables: -
//
// Side Effects    : 
//   
//   This is hairy! E's internal types do not map very well to
//   TSTP types, and E uses the "initial" properties in ways that
//   make it highly desirable that anything in the input is
//   actually initial (the CPInitialProperty is actually set in
//   all clauses in the initial unprocessed clause set. So we
//   ignore the "derived" modifier, and use CPTypeAxiom for plain
//   clauses. 
//
/----------------------------------------------------------------------*/

function WFormulaTSTPParse( _in_,terms )
{
   var en = new g_TPTtoken()
   var vn = new WFormulaProperties()
   var tform = new TFormula_p(); 
   var type = new WFormulaProperties()
   type = WPTypeAxiom(type)
   var initial = new WFormulaProperties()
   initial = WPInputFormula(initial)
   var handle = new WFormula_p()
   var info = new ClauseInfo_p()
   info = ClauseInfoAlloc(NULL, DStrView(AktToken(_in_).source), 
                          AktToken(_in_).line, 
                          AktToken(_in_).column); 
      
   _in_ = AcceptInpId(_in_, "fof")
   _in_ = AcceptInpTok(_in_, en.OpenBracket)
   _in_ = CheckInpTok(_in_, en.Name|en.PosInt|en.SQString)
   info.name = DStrCopy(AktToken(_in_).literal)
   _in_ = NextToken(_in_)
   _in_ = AcceptInpTok(_in_, en.Comma)
   type = ClauseTypeParse(_in_, 
                          "axiom|hypothesis|definition|assumption|"
                          "lemma|theorem|conjecture|question|negated_conjecture|"
                          "plain|unknown")
   _in_ = AcceptInpTok(_in_, en.Comma)
   tform = TFormulaTSTPParse(_in_, terms)
   handle = WTFormulaAlloc(terms, tform)
   if(TestInpTok(_in_, Comma))
   {
      _in_ = AcceptInpTok(_in_, en.Comma)
      _in_ = TSTPSkipSource(_in_)
      if(TestInpTok(_in_, en.Comma))
      {
         _in_ = AcceptInpTok(_in_, en.Comma)
         _in_ = CheckInpTok(_in_, en.OpenSquare)
         _in_ = ParseSkipParenthesizedExpr(_in_)
      }
   }
   _in_ = AcceptInpTok(_in_, en.CloseBracket)
   _in_ = AcceptInpTok(_in_, en.Fullstop)
   handle = FormulaSetType(handle, type)
   handle = FormulaSetProp(handle, vn.initial|vn.WPInitial)
   handle.info = info

   return { handle:handle,_in_:_in_ }
}

/*-----------------------------------------------------------------------
//
// Function: WFormulaParse()
//
//   Parse a formula in any supported input format.
//
// Global Variables: -
//
// Side Effects    : Input
//
/----------------------------------------------------------------------*/

function WFormulaParse(_in_,terms)
{
   var en = new IOFormat()
   var wform = new WFormula_p()
   if(ClausesHaveDisjointVariables)
   {
      terms.vars = VarBankClearExtNamesNoReset(terms.vars)
   }
   var status = {}
   status[en.LOPFormat] = function(){ Error("LOP currently does not support full FOF!", OTHER_ERROR) }
   status[en.TPTPFormat] = function(_in_,terms){ return WFormulaTPTPParse(_in_, terms) }
   status[en.TSTPFormat] = function(_in_,terms){ return WFormulaTSTPParse(_in_, terms) }
   status['default'] = function(_in_,terms){ console.log('WFormulaParse - Incompatible format: ',_in_,'. Expecting LOP | TPTP | TSTP | etc.') }
   var v = ScannerGetFormat(_in_)
   if(status[v])
   {
      wform = status[v](_in_,terms)
   }
   else
   {
      status['default']
   }
   
   return wform
}

/*-----------------------------------------------------------------------
//
// Function: FormulaSetInsert()
//
//   Insert newnode into set.
//
// Global Variables: -
//
// Side Effects    : -
//
/----------------------------------------------------------------------*/

function FormulaSetInsert( set,newform )
{
   console.log('FormulaSetInsert ',set,newform,!newform.set)
   
   newform.succ = set.anchor
   newform.pred = set.anchor.pred
   set.anchor.pred.succ = newform
   set.anchor.pred = newform
   newform.set = set
   set.members++

   return { fset:set,form:newform }
}

/*-----------------------------------------------------------------------
//
// Function: FormulaAndClauseSetParse()
//
//   Parse a mixture of clauses and formulas (if the syntax supports
//   it). Return number of elements parsed (even if discarded by
//   filter).
//
// Global Variables: -
//
// Side Effects    : Input, changes termbank and sets.
//
/----------------------------------------------------------------------*/

function FormulaAndClauseSetParse( _in_,cset,fset,terms,name_selector,skip_includes )
{
   var res = 0
   var form = new WFormula_p()
   var nextform = = new WFormula_p()
   var clause = new Clause_p()
   var nextclause = new Clause_p()
   var stand_in = new StrTree_p()

   if(!name_selector)
   {
      name_selector = stand_in
   }
   
   switch(ScannerGetFormat(_in_))
   {
      case LOPFormat:
         res = ClauseSetParseList(_in_, cset, terms)
         break
      default:
         while(TestInpId(_in_, "input_formula|input_clause|fof|cnf|include"))
         {
            if(TestInpId(_in_, "include"))
            {
               var new_limit = new StrTree_p()
               var new_in = new Scanner_p()
               var ncset = new ClauseSet_p()
               ncset = ClauseSetAlloc(ncset)
               var nfset = new FormulaSet_p()
               nfset = FormulaSetAlloc(nfset)
               
               new_in = ScannerParseInclude(_in_, new_limit, skip_includes)
               if(new_in)
               {
                  res += FormulaAndClauseSetParse(new_in, 
                    ncset, 
                    nfset, 
                    terms, 
                    new_limit,
                    skip_includes)
                  DestroyScanner(new_in)
               }
               StrTreeFree(new_limit)
               var v = ClauseSetInsertSet(cset, ncset)
               cset = v.set
               res = v.res
               v = undefined
               fset = FormulaSetInsertSet(fset, nfset)
               console.log('FormulaAndClauseSetParse ',ClauseSetEmpty(ncset))
               console.log('FormulaAndClauseSetParse ',ClauseSetEmpty(nfset))
               ClauseSetFree(ncset)
               FormulaSetFree(nfset)
            }
            else
            {
               if(TestInpId(_in_, "input_formula|fof"))
               {
                  form = WFormulaParse(_in_, terms)
                  var v = FormulaSetInsert(fset, form)
                  fset = v.fset
                  form = v.form
                  v = undefined
               }
               else
               {
                  console.log('FormulaAndClauseSetParse ',TestInpId(_in_, "input_clause|cnf"))
                  clause = ClauseParse(_in_, terms)
                  cset = ClauseSetInsert(cset, clause)
               }
               res++
            }
         }
         break
   }
   if(name_selector)
   {
      form = fset.anchor.succ
      while(form != fset.anchor)
      {
         nextform = form.succ
         if(!verify_name(name_selector, form.info))
         {
            FormulaSetDeleteEntry(form)
         }
         form = nextform
      }
      clause = cset.anchor.succ
      while(clause != cset.anchor)
      {
         nextclause = clause.succ
         if(!verify_name(name_selector, clause.info))
         {
            ClauseSetDeleteEntry(clause)
         }
         clause = nextclause
      }
      _in_ = check_all_found(_in_, name_selector)
   }
   return res
}

/*---------------------------------------------------------------------*/
/*                         Internal Functions                          */
/*---------------------------------------------------------------------*/

/*-----------------------------------------------------------------------
//
// Function: parse_spec()
//
//   Allocate proof state, parse input files into it, and check that
//   requested properties are met. Factored from MAIN for reasons of
//   readability and length.
//
// Global Variables: -
//
// Side Effects    : Memory, input, may terminate with error.
//
/----------------------------------------------------------------------*/

function parse_spec(state,          // CLState_p
                    parse_format,   // IOFormat
                    error_on_empty, // bool
                    free_symb_prop, // FunctionProperties
                    ax_no           // int (axiom number)
                        )
{
   var en = new g_TPTtoken()
   var proofstate = new ProofState_p();
   var _in_ = new Scanner_p();
   var skip_includes = new StrTree_p() // NULL;
   var parsed_ax_no;

   proofstate = ProofStateAlloc(free_symb_prop);
   for(var i=0; state.argv[i]; i++)
   {
      _in_ = CreateScanner(StreamTypeFile, state.argv[i], true, NULL);
      ScannerSetFormat(_in_, parse_format);
      
      FormulaAndClauseSetParse(_in_, proofstate.axioms, 
                               proofstate.f_axioms,
                               proofstate.original_terms, 
                               NULL,
                               skip_includes);
      CheckInpTok(_in_, en.NoToken);
      DestroyScanner(_in_); 
   }
   VERBOUT2("Specification read\n");

   parsed_ax_no = ProofStateAxNo(proofstate);

   if(error_on_empty && (parsed_ax_no == 0))
   {
        if(PRINT_SOMEERRORS_STDOUT){
            console.log("parse_spec: # Error: Input file contains no clauses or formulas");
        }
        throw "Input file contains no clauses or formulas"
   }
   return { proofstate:proofstate,ax_no:parsed_ax_no }
}

/*---------------------------------------------------------------------*/
/*                    Data type declarations                           */
/*---------------------------------------------------------------------*/
var EXIT_SUCCESS = 1<<0

function typedef_enum_ErrorCodes()
{
    function obj()
    {
        this.NO_ERROR = EXIT_SUCCESS
        this.PROOF_FOUND = EXIT_SUCCESS
        this.SATISFIABLE = 1<<2
        this.OUT_OF_MEMORY = 1<<3
        this.SYNTAX_ERROR = 1<<4
        this.USAGE_ERROR = 1<<5
        this.FILE_ERROR = 1<<6
        this.SYS_ERROR = 1<<7
        this.CPU_LIMIT_ERROR = 1<<8
        this.RESOURCE_OUT = 1<<9
        this.INCOMPLETE_PROOFSTATE = 1<<10
        this.OTHER_ERROR = 1<<11
        this.INPUT_SEMANTIC_ERROR = 1<<12
    }
    return obj
}
var ErrorCodes = typedef_enum_ErrorCodes()

/*-----------------------------------------------------------------------
//
// Function: main()
//
//   Main entry point of the prover.
//
// Global Variables: Plenty, mostly flags shared with
//                   process_options. See list above.
//
// Side Effects    : Yes ;-)
//
/----------------------------------------------------------------------*/

function main()
{
   var en = new ErrorCodes()
   var argc = arguments.length
   var argv = arguments
   var retval = en.NO_ERROR
   var state = new CLState_p()
   var proofstate = new ProofState_p()
   var proofcontrol = new ProofControl_p()
   var success = new Clause_p()
   var filter_success
   var out_of_clauses
   var finals_state = "exists"
   var sat_status = "Derivation"
   var raw_clause_no 
   var preproc_removed=0
   var neg_conjectures
   var parsed_ax_no
   var relevancy_pruned = 0
   var preproc_time
   var pid = new pid_t(1)
   console.log('Main: ',argv[0])
   InitIO(NAME)
if(STACK_SIZE)
{
   IncreaseMaxStackSize(argv, STACK_SIZE)
}
   ESignalSetup(SIGXCPU)
   h_parms = HeuristicParmsAlloc()
   fvi_parms = FVIndexParmsAlloc();   
   wfcb_definitions = PStackAlloc()
   hcb_definitions = PStackAlloc()
   state = process_options(argc, argv)
   
   OpenGlobalOut(outname)
   print_info()
   if(state.argc ==  0)
   {
      CLStateInsertArg(state, "-")
   }
   var v = parse_spec(state, parse_format, 
                           error_on_empty, free_symb_prop,
                           parsed_ax_no)
   proofstate = v.proofstate
   parsed_ax_no = v.parsed_ax_no
   v = undefined
   relevancy_pruned += ProofStateSinE(proofstate, sine)
   relevancy_pruned += ProofStatePreprocess(proofstate, relevance_prune_level)
   if(strategy_scheduling)
   {
      ExecuteSchedule(StratSchedule, h_parms, print_rusage)
   }
   
   FormulaSetDocInital(GlobalOut, OutputLevel, proofstate.f_axioms)
   ClauseSetDocInital(GlobalOut, OutputLevel, proofstate.axioms)
   if(prune_only)
   {
      console.log("Main: # Pruning successful!")
      srcTranslated.value += "Unknown"
      goto cleanup1
   }
   if(relevancy_pruned || incomplete)
   {
      proofstate.state_is_complete = false
   }
   if(BuildProofObject)
   {
      FormulaSetArchive(proofstate.f_axioms, proofstate.f_ax_archive)
   }   
   if((neg_conjectures =
       FormulaSetPreprocConjectures(proofstate.f_axioms, 
                                    proofstate.f_ax_archive,
                                    answer_limit>0, 
                                    conjectures_are_questions)))
   {
      VERBOUT("Negated conjectures.\n")
   }
   if(FormulaSetCNF(proofstate.f_axioms,
                    proofstate.f_ax_archive,
                    proofstate.axioms, 
                    proofstate.original_terms, 
                    proofstate.freshvars,
                    proofstate.gc_original_terms))
   {
      VERBOUT("CNFization done\n")
   }
   ProofStateInitWatchlist(proofstate, watchlist_filename, parse_format)
   raw_clause_no = proofstate.axioms.members
   if(!no_preproc)
   {
      if(BuildProofObject)
      {
         ClauseSetArchive(proofstate.ax_archive, proofstate.axioms)
         if(proofstate.watchlist)
         {
            ClauseSetArchive(proofstate.ax_archive, proofstate.watchlist)
         }
      }
      preproc_removed = ClauseSetPreprocess(proofstate.axioms,
                        proofstate.watchlist,
                                            proofstate.archive,
                        proofstate.tmp_terms,
                        eqdef_incrlimit, 
                                            eqdef_maxclauses)
   }
   proofcontrol = ProofControlAlloc()
   ProofControlInit(proofstate, proofcontrol, h_parms, 
                    fvi_parms, wfcb_definitions, hcb_definitions)
   var s = new PCLFullTerm()
   s = pcl_full_terms(s); 
   ProofStateInit(proofstate, proofcontrol)
   console.log("Main: Prover state initialized");   
   preproc_time = GetTotalCPUTime()
   if(print_rusage)
   {
      console.log("Main: # Preprocessing time       : %.3f s", preproc_time)
   }
   if(proofcontrol.heuristic_parms.presat_interreduction)
   {
      var sel_strat = new LiteralSelectionFun() = 
         proofcontrol.heuristic_parms.selection_strategy
      proofcontrol.heuristic_parms.selection_strategy = SelectNoGeneration
      success = Saturate(proofstate, proofcontrol, LONG_MAX,
                         LONG_MAX, LONG_MAX, LONG_MAX, LONG_MAX)
      console.log("Main: # Presaturation interreduction done")
      proofcontrol.heuristic_parms.selection_strategy = sel_strat
      if(!success)
      {
         ProofStateResetProcessed(proofstate, proofcontrol)
      }
   }
   PERF_CTR_ENTRY(SatTimer)
   
   if(!success)
   {      
      success = Saturate(proofstate, proofcontrol, step_limit,
                         proc_limit, unproc_limit, total_limit, answer_limit)
   }
   PERF_CTR_EXIT(SatTimer)
   
   out_of_clauses = ClauseSetEmpty(proofstate.unprocessed)
   if(filter_sat)
   {
      filter_success = ProofStateFilterUnprocessed(proofstate,
                           proofcontrol,
                           filterdesc)
      if(filter_success)
      {
         success = filter_success
         PStackPushP(proofstate.extract_roots, success)
      }
   }
   
   if(success||proofstate.answer_count)
   {
      console.log(!PStackEmpty(proofstate.extract_roots))
      if(success)
      {
         DocClauseQuoteDefault(2, success, "proof")
      }      
      console.log("Main: # Proof found!")
      if(!proofstate.status_reported)
      {
         console.log("Main: neg_conjectures -  ",neg_conjectures?"Theorem":"Unsatisfiable")
         proofstate.status_reported = true
         retval = en.PROOF_FOUND
      }      
      if(BuildProofObject)
      {
         var derivation = new Derivation_p() = 
            DerivationCompute(proofstate.extract_roots, 
                              proofstate.signature)
         DerivationPrint(GlobalOut, derivation, "CNFRefutation")
         DerivationFree(derivation)
      }
   }
   else if(proofstate.watchlist && ClauseSetEmpty(proofstate.watchlist))
   {      
      ProofStatePropDocQuote(GlobalOut, OutputLevel, 
                 CPSubsumesWatch, proofstate, 
                 "final_subsumes_wl")
      console.log("Main: # Watchlist is empty! ","ResourceOut")
      retval = RESOURCE_OUT
   }
   else
   {
      if(out_of_clauses && 
     proofstate.state_is_complete && 
     (inf_sys_complete || assume_inf_sys_complete))
      {
         finals_state = "final"
      }
      ProofStatePropDocQuote(GlobalOut, OutputLevel, CPIgnoreProps,
                 proofstate, finals_state)
      if(cnf_only)
      {
         console.log("Main: # CNFization successful!")
      }
      else if(out_of_clauses)
      {
     if(!(inf_sys_complete || assume_inf_sys_complete))
     {
        console.log("Main: # Clause set closed under restricted calculus! GaveUp en.INCOMPLETE_PROOFSTAT")
            retval = en.INCOMPLETE_PROOFSTATE
     }
     else if(proofstate.state_is_complete && inf_sys_complete)
     {
        console.log("Main: # No proof found! Saturation en.SATISFIABLE ", neg_conjectures?"CounterSatisfiable":"Satisfiable")
            sat_status = "Saturation"
            retval = en.SATISFIABLE
     }
     else
     {
        console.log("Main:# Failure: Out of unprocessed clauses! GaveUp en.INCOMPLETE_PROOFSTATE") 
            retval = en.INCOMPLETE_PROOFSTATE
     }
      }
      else 
      {
     console.log("Main:# Failure: User resource limit exceeded! en.RESOURCE_OUT ResourceOut")
         retval = en.RESOURCE_OUT
      }
      if(BuildProofObject)
      {
         var derivation = new Derivation_p()
         ClauseSetPushClauses(proofstate.extract_roots, 
                              proofstate.processed_pos_rules)
         ClauseSetPushClauses(proofstate.extract_roots,
                              proofstate.processed_pos_eqns)
         ClauseSetPushClauses(proofstate.extract_roots,
                              proofstate.processed_neg_units)
         ClauseSetPushClauses(proofstate.extract_roots,
                              proofstate.processed_non_units)
         derivation = DerivationCompute(proofstate.extract_roots, 
                                        proofstate.signature)
         DerivationPrint(GlobalOut, derivation, sat_status)
         DerivationFree(derivation)
      }
   }
   
   if(print_sat)
   {
      if(proofstate.non_redundant_deleted)
      {
         console.log("Main:# Saturated system is incomplete!")
      }
      if(success)
      {
         console.log("Main: # Saturated system contains the empty clause:")
      }
      ProofStatePrintSelective(GlobalOut, proofstate, outdesc,
                   outinfo)
      console.log("")
   }     
   
   if(success)
   {
      ClauseFree(success)
   }
   fflush(GlobalOut)
   
   if(OutputLevel||print_statistics)
   {
      console.log( "Main: # Parsed axioms                        : ",
              parsed_ax_no)
      console.log( "Main: # Removed by relevancy pruning/SinE    : ",
              relevancy_pruned)
      console.log( "Main: # Initial clauses                      : ",
          raw_clause_no)
      console.log( "Main: # Removed in clause preprocessing      : ",
          preproc_removed)
      ProofStateStatisticsPrint(GlobalOut, proofstate)
      console.log("Main: # Clause-clause subsumption calls (NU) : ",
          ClauseClauseSubsumptionCalls)
      console.log( "Main: # Rec. Clause-clause subsumption calls : ",
          ClauseClauseSubsumptionCallsRec)
      console.log( "Main: # Non-unit clause-clause subsumptions  : ",
          ClauseClauseSubsumptionSuccesses)
      console.log( "Main: # Unit Clause-clause subsumption calls : ",
              UnitClauseClauseSubsumptionCalls)
      console.log( "Main: # Rewrite failures with RHS unbound    : ",
              RewriteUnboundVarFails)
      console.log( "Main: # BW rewrite match attempts            : ",
              BWRWMatchAttempts)
      console.log( "Main: # BW rewrite match successes           : ",
              BWRWMatchSuccesses)
      console.log( "Main: # Condensation attempts                : ",
              CondensationAttempts)
      console.log( "Main: # Condensation successes               : ",
              CondensationSuccesses)
if( MEASURE_UNIFICATION )
{
      console.log( "Main: # Unification attempts                 : ",
              UnifAttempts)
      console.log( "Main: # Unification successes                : ",
              UnifSuccesses)
}
      PERF_CTR_PRINT(GlobalOut, MguTimer)
      PERF_CTR_PRINT(GlobalOut, SatTimer)
      PERF_CTR_PRINT(GlobalOut, ParamodTimer)
      PERF_CTR_PRINT(GlobalOut, PMIndexTimer)
      PERF_CTR_PRINT(GlobalOut, IndexUnifTimer)
      PERF_CTR_PRINT(GlobalOut, BWRWTimer)
      PERF_CTR_PRINT(GlobalOut, BWRWIndexTimer)
      PERF_CTR_PRINT(GlobalOut, IndexMatchTimer)
      PERF_CTR_PRINT(GlobalOut, FreqVecTimer)
      PERF_CTR_PRINT(GlobalOut, FVIndexTimer)
      PERF_CTR_PRINT(GlobalOut, SubsumeTimer)
      PERF_CTR_PRINT(GlobalOut, SetSubsumeTimer)
if( PRINT_INDEX_STATS )
{
      console.log("# Backwards rewriting index : ")
      FPIndexDistribDataPrint(GlobalOut, proofstate.gindices.bw_rw_index)
      console.log("")
      
      console.log("# Paramod-from index        : ")
      FPIndexDistribDataPrint(GlobalOut, proofstate.gindices.pm_from_index)
      console.log("")
      FPIndexPrintDot(GlobalOut, "pm_from_index", 
                      proofstate.gindices.pm_from_index,
                      SubtermTreePrintDot,
                      proofstate.signature)
      console.log("# Paramod-into index        : ")
      FPIndexDistribDataPrint(GlobalOut, proofstate.gindices.pm_into_index)
      console.log("")
      console.log("# Paramod-neg-atom index    : ")
      FPIndexDistribDataPrint(GlobalOut, proofstate.gindices.pm_negp_index)
      console.log("")
}
   }   
if( !FAST_EXIT )
{
   if( FULL_MEM_STATS )
   {
      console.log("Main: # sizeof TermCell     : ",sizeof(TermCell))
      console.log("Main: # sizeof EqnCell      : ",sizeof(EqnCell))
      console.log("Main: # sizeof ClauseCell   : ",sizeof(ClauseCell))
      console.log("Main: # sizeof PTreeCell    : ",sizeof(PTreeCell))
      console.log("Main: # sizeof PDTNodeCell  : ",sizeof(PDTNodeCell))
      console.log("Main: # sizeof EvalCell     : ",sizeof(EvalCell))
      console.log("Main: # sizeof ClausePosCell: ",sizeof(ClausePosCell))
      console.log("Main: # sizeof PDArrayCell  : ",sizeof(PDArrayCell))
      console.log("Main: # Estimated memory usage: ",ProofStateStorage(proofstate))
      MemFreeListPrint(GlobalOut)
   }
   ProofControlFree(proofcontrol)
}

cleanup1:
if( !FAST_EXIT )
{
   ProofStateFree(proofstate)
   CLStateFree(state)
   PStackFree(hcb_definitions)
   PStackFree(wfcb_definitions)
   FVIndexParmsFree(fvi_parms)
   HeuristicParmsFree(h_parms)
   if( FULL_MEM_STATS )
   {
      MemFreeListPrint(GlobalOut)
   }
}
   if(print_rusage && pid)
   {
      PrintRusage(GlobalOut)
   }
   if(!pid)
   {
      return retval
   }
   fflush(GlobalOut)
   OutClose(GlobalOut)
   ExitIO()
if( CLB_MEMORY_DEBUG )
{
   RegMemCleanUp()
   MemFlushFreeList()
   MemDebugPrintStats(stdout)
}
   return retval
} // main ()

addEventListener('message', my_func,'logic.js')

function my_func(e){ // part_of_speech lookup
    try{
        var st = e.data.split(/\s*\n+/)
    } catch(e) {
        if(!sentence){
            var sentence = []
        }
        sentence.push('Logic Library - '+e)
        console.log(e)
    }
    postMessage ( { origin:'mysql_wn_data_99',value:sentence } )
}